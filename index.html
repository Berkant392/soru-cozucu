<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI Kripto Sinyal Asistanƒ± v2.5 (Geli≈ümi≈ü S√ºr√ºm)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0d1117; color: #c9d1d9; }
        .glass-effect { background: rgba(22, 27, 34, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(48, 54, 61, 0.5); }
        .signal-card { transition: all 0.3s ease; border-left-width: 4px; }
        .signal-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .blinking { animation: blink 1.5s linear infinite; }
        @keyframes blink { 50% { opacity: 0.4; } }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #161b22; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #485058; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        /* Terminal Stilleri */
        #ai-terminal {
            font-family: 'Roboto Mono', monospace;
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 380px;
            max-width: 90vw;
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            color: #c9d1d9;
            z-index: 100;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .terminal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background-color: #21262d;
            border-bottom: 1px solid #30363d;
        }
        .terminal-header .dots { display: flex; gap: 0.5rem; }
        .terminal-header .dot { width: 12px; height: 12px; border-radius: 50%; }
        .terminal-header .dot-red { background-color: #ff5f56; }
        .terminal-header .dot-yellow { background-color: #ffbd2e; }
        .terminal-header .dot-green { background-color: #27c93f; }
        .terminal-header .title { font-weight: 500; color: #f0f6fc; font-size: 0.9rem; }
        .terminal-header .status { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; color: #27c93f; }
        .terminal-header .status-indicator { width: 8px; height: 8px; background-color: #27c93f; border-radius: 50%; animation: blink 1.5s linear infinite; }
        .terminal-body { padding: 0.75rem; height: 120px; overflow-y: auto; font-size: 0.8rem; }
        .terminal-body p { margin-bottom: 0.5rem; display: flex; align-items: flex-start; }
        .terminal-body p .icon { margin-right: 0.5rem; margin-top: 2px; }
        .terminal-body .log-info { color: #58a6ff; }
        .terminal-body .log-success { color: #3fb950; }
        .terminal-body .log-scan { color: #a371f7; }
        .terminal-body .log-error { color: #f85149; }
        .terminal-progress-bar {
            width: calc(100% - 1.5rem);
            margin: 0 0.75rem 0.75rem 0.75rem;
            height: 18px;
            background-color: #0d1117;
            border-radius: 0.375rem;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        .terminal-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #27c93f, #3fb950);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: #ffffff;
        }
        /* Dinamik Fiyat √áubuƒüu Stilleri */
        .price-progress-bar {
            background: linear-gradient(to right, #ef4444, #f59e0b, #84cc16);
            border-radius: 0.25rem;
            height: 8px;
            position: relative;
            margin-top: 4px;
        }
        .price-indicator {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 12px;
            background-color: #ffffff;
            border-radius: 2px;
            transform: translateX(-50%);
            transition: left 0.5s ease;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="main-container" class="flex flex-col lg:flex-row h-screen max-h-screen p-4 gap-4">
        <aside class="w-full lg:w-1/4 xl:w-1/5 flex flex-col glass-effect rounded-2xl p-4 space-y-4">
            <div class="flex items-center justify-between"><h2 class="text-xl font-bold text-white">Piyasa</h2><div id="connection-status" class="flex items-center gap-2 text-xs"><div class="status-dot bg-yellow-400"></div><span>Baƒülanƒ±yor...</span></div></div>
            <div class="relative"><input type="text" id="coin-search" placeholder="Coin Ara..." class="w-full bg-[#0d1117] border border-gray-700 rounded-lg px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500"></div>
            <div id="coin-list" class="flex-grow overflow-y-auto pr-2"></div>
        </aside>
        <main class="w-full lg:w-3/4 xl:w-4/5 flex flex-col gap-4">
            <header class="glass-effect rounded-2xl p-6 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div><h1 class="text-3xl font-bold text-white">AI Trader Asistanƒ± v2.5 (Geli≈ümi≈ü)</h1><p class="text-gray-400">Tahminsel ve Adapte Olan Analiz</p></div>
                <div id="stats-container" class="glass-effect rounded-lg p-4 w-full md:w-auto text-center">
                    <h3 class="text-lg font-semibold text-white mb-2">Ba≈üarƒ± ƒ∞statistiƒüi</h3>
                    <div class="flex justify-around gap-4 text-sm">
                        <div><p class="text-gray-400">Toplam Sinyal</p><p id="total-signals" class="text-2xl font-bold text-white">0</p></div>
                        <div><p class="text-gray-400">Ba≈üarƒ±lƒ±</p><p id="successful-signals" class="text-2xl font-bold text-green-400">0</p></div>
                        <div><p class="text-gray-400">Stop</p><p id="stopped-signals" class="text-2xl font-bold text-red-400">0</p></div>
                        <div><p class="text-gray-400">Ba≈üarƒ± %</p><p id="success-rate" class="text-2xl font-bold text-blue-400">N/A</p></div>
                    </div>
                </div>
            </header>
            <div id="signals-grid" class="flex-grow overflow-y-auto p-2 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-4">
                 <div id="placeholder-card" class="flex flex-col items-center justify-center text-center text-gray-500 h-full col-span-full">
                    <svg class="w-16 h-16 mb-4 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h7.5M8.25 12h7.5m-7.5 5.25h7.5M3.75 6.75h.007v.008H3.75V6.75zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zM3.75 12h.007v.008H3.75V12zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm-.375 5.25h.007v.008H3.75v-.008zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg>
                    <p class="text-xl font-medium">Uygulama Ba≈ülatƒ±lƒ±yor...</p>
                </div>
            </div>
        </main>
    </div>
    <div id="details-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center hidden z-50 p-4">
        <div class="glass-effect rounded-2xl p-6 w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4"><h3 id="modal-title" class="text-2xl font-bold text-white">Analiz Detaylarƒ±</h3><button id="close-modal" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button></div>
            <div id="modal-content" class="overflow-y-auto text-gray-300 space-y-4 pr-2"></div>
        </div>
    </div>

    <!-- AI Terminali -->
    <div id="ai-terminal">
        <div class="terminal-header">
            <div class="dots">
                <div class="dot dot-red"></div>
                <div class="dot dot-yellow"></div>
                <div class="dot dot-green"></div>
            </div>
            <span class="title">AI Trader Terminal v2.5</span>
            <div class="status">
                <div class="status-indicator"></div>
                <span>LIVE</span>
            </div>
        </div>
        <div class="terminal-body" id="terminal-output"></div>
        <div class="terminal-progress-bar">
            <div class="terminal-progress" id="terminal-progress-indicator">0%</div>
        </div>
    </div>

    <div id="critical-error-overlay" class="fixed inset-0 bg-red-900 bg-opacity-95 flex-col text-white items-center justify-center hidden z-[100] p-8 text-center">
        <h2 class="text-3xl font-bold mb-4">Kritik Hata: K√ºt√ºphane Ba≈ülatƒ±lamadƒ±</h2>
        <p class="mb-2 max-w-2xl">Uygulamanƒ±n √ßalƒ±≈ümasƒ± i√ßin gerekli olan 'technicalindicators' k√ºt√ºphanesi ba≈ülatƒ±lamadƒ±. G√∂m√ºl√º kodda bir sorun olabilir.</p>
    </div>
    
    <!-- G√∂m√ºl√º technicalindicators k√ºt√ºphanesi (Geli≈ümi≈ü ve Stabil S√ºr√ºm) -->
    <script>
        (function(global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
                typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (factory((global.technicalindicators = global.technicalindicators || {})));
        }(this, (function(exports) {
            'use strict';
            class Indicator {
                constructor() {
                    this.result = [];
                    this.format = (data) => {
                        return data;
                    };
                }
                static calculate(input) {
                    console.error('The calculate method is not implemented');
                    return;
                }
                getResult() {
                    return this.result;
                }
            }

            class MA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var result = new Array(values.length);
                    this.result = result;
                    this.generator = (function*() {
                        var sum = 0;
                        var period = yield;
                        var price = yield;
                        var data = new Array(period);
                        var i = 0;
                        var result;
                        while (true) {
                            if (i < period) {
                                data[i] = price;
                                sum = sum + price;
                                result = undefined;
                            } else {
                                sum = sum - data[i % period] + price;
                                result = sum / period;
                            }
                            i++;
                            data[i % period] = price;
                            price = yield result;
                        }
                    })();
                    this.generator.next();
                    this.generator.next(period);
                    values.forEach((tick, index) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result[index] = this.format(result.value);
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined)
                        return this.format(result);
                }
            }

            class SMA extends MA {
                constructor(input) {
                    super(input);
                }
                static calculate(input) {
                    var period = input.period;
                    var values = input.values;
                    var sma = new SMA({
                        period: period,
                        values: []
                    });
                    var results = [];
                    values.forEach(price => {
                        var result = sma.nextValue(price);
                        if(result !== undefined) results.push(result);
                    });
                    return results;
                }
            }

            class EMA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var k = 2 / (period + 1);
                    this.result = [];
                    this.generator = (function*() {
                        var last_ema;
                        var tick = yield;
                        var ma = new SMA({
                            period: period,
                            values: []
                        });
                        while (tick != undefined) {
                            var next_value = ma.nextValue(tick);
                            if (next_value != undefined) {
                                last_ema = next_value;
                                break;
                            }
                            tick = yield;
                        }
                        tick = yield last_ema;
                        while (true) {
                            last_ema = (tick - last_ema) * k + last_ema;
                            tick = yield last_ema;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                     return new EMA(input).getResult();
                }
            }
            
            class MACD extends Indicator {
                constructor(input) {
                    super();
                    var fastMAProducer = input.SimpleMAOscillator === false ? EMA : SMA;
                    var slowMAProducer = input.SimpleMAOscillator === false ? EMA : SMA;
                    var signalMAProducer = input.SimpleMASignal === false ? EMA : SMA;
                    var fastPeriod = input.fastPeriod;
                    var slowPeriod = input.slowPeriod;
                    var signalPeriod = input.signalPeriod;
                    var values = input.values;
                    var fastMA = new fastMAProducer({
                        period: fastPeriod,
                        values: []
                    });
                    var slowMA = new slowMAProducer({
                        period: slowPeriod,
                        values: []
                    });
                    var signalMA = new signalMAProducer({
                        period: signalPeriod,
                        values: []
                    });
                    this.result = [];
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var macd, signal, histogram;
                        while (true) {
                            var fast = fastMA.nextValue(tick);
                            var slow = slowMA.nextValue(tick);
                            if (fast != undefined && slow != undefined) {
                                macd = fast - slow;
                                signal = signalMA.nextValue(macd);
                                if (signal != undefined) {
                                    histogram = macd - signal;
                                }
                            }
                            result = {
                                MACD: macd,
                                signal: signal,
                                histogram: histogram
                            };
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value.MACD != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result.MACD != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new MACD(input).getResult();
                }
            }
            
            class RSI extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var values = input.values;
                    var GainProvider = new(function() {
                        var lastValue;
                        this.nextValue = function(value) {
                            if (lastValue === undefined) {
                                lastValue = value;
                                return;
                            }
                            var gainValue = value - lastValue;
                            lastValue = value;
                            return gainValue > 0 ? gainValue : 0;
                        };
                    })();
                    var LossProvider = new(function() {
                        var lastValue;
                        this.nextValue = function(value) {
                            if (lastValue === undefined) {
                                lastValue = value;
                                return;
                            }
                            var lossValue = value - lastValue;
                            lastValue = value;
                            return lossValue < 0 ? Math.abs(lossValue) : 0;
                        };
                    })();
                    var avgGain = new SMA({ period: period, values: [] });
                    var avgLoss = new SMA({ period: period, values: [] });
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var currentGain, currentLoss, lastAvgGain, lastAvgLoss, rs;
                        while (true) {
                            currentGain = GainProvider.nextValue(tick);
                            currentLoss = LossProvider.nextValue(tick);
                            if (currentGain === undefined || currentLoss === undefined) {
                                tick = yield;
                                continue;
                            }
                            if (lastAvgGain === undefined) {
                                lastAvgGain = avgGain.nextValue(currentGain);
                                lastAvgLoss = avgLoss.nextValue(currentLoss);
                                if (lastAvgGain !== undefined && lastAvgLoss !== undefined && lastAvgLoss !== 0) {
                                    rs = lastAvgGain / lastAvgLoss;
                                    result = 100 - 100 / (1 + rs);
                                }
                            } else {
                                lastAvgGain = (lastAvgGain * (period - 1) + currentGain) / period;
                                lastAvgLoss = (lastAvgLoss * (period - 1) + currentLoss) / period;
                                if(lastAvgLoss !== 0) {
                                    rs = lastAvgGain / lastAvgLoss;
                                    result = 100 - 100 / (1 + rs);
                                } else {
                                    result = 100;
                                }
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new RSI(input).getResult();
                }
            }

            class BollingerBands extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var values = input.values;
                    var stdDev = input.stdDev;
                    var ma = new SMA({ period: period, values: [] });
                    this.result = [];
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var data = new Array(period);
                        var i = 0;
                        while (true) {
                            data[i % period] = tick;
                            i++;
                            var middle = ma.nextValue(tick);
                            if (middle != undefined) {
                                var sum = 0;
                                for (var j = 0; j < data.length; j++) {
                                    sum = sum + (data[j] - middle) * (data[j] - middle);
                                }
                                var stdev = Math.sqrt(sum / period);
                                result = {
                                    middle: middle,
                                    upper: middle + stdev * stdDev,
                                    lower: middle - stdev * stdDev,
                                    pb: (tick - (middle - stdev * stdDev)) / ((middle + stdev * stdDev) - (middle - stdev * stdDev))
                                };
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new BollingerBands(input).getResult();
                }
            }

            class TrueRange extends Indicator {
                constructor(input) {
                    super();
                    this.high = input.high || [];
                    this.low = input.low || [];
                    this.close = input.close || [];
                    this.result = [];
                    this.generator = (function* () {
                        let lastClose;
                        let tick = yield;
                        while (true) {
                            let trueRange;
                            if (lastClose !== undefined) {
                                trueRange = Math.max(tick.high - tick.low, Math.abs(tick.high - lastClose), Math.abs(tick.low - lastClose));
                            } else {
                                trueRange = tick.high - tick.low;
                            }
                            lastClose = tick.close;
                            tick = yield trueRange;
                        }
                    })();
                    this.generator.next();
                    this.high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: this.low[index], close: this.close[index] };
                        const result = this.generator.next(tick);
                        if (result.value !== undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(tick) {
                    const result = this.generator.next(tick).value;
                    if (result !== undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new TrueRange(input).getResult();
                }
            }
            
            class WEMA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var k = 1 / period;
                    this.result = [];
                    this.generator = (function*() {
                        var last_wema;
                        var tick = yield;
                        var ma = new SMA({ period: period, values: [] });
                        while (tick != undefined) {
                            var next_value = ma.nextValue(tick);
                            if (next_value != undefined) {
                                last_wema = next_value;
                                break;
                            }
                            tick = yield;
                        }
                        tick = yield last_wema;
                        while (true) {
                            last_wema = (tick * k) + (last_wema * (1 - k));
                            tick = yield last_wema;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new WEMA(input).getResult();
                }
            }

            class ATR extends Indicator {
                constructor(input) {
                    super();
                    let period = input.period;
                    let high = input.high || [];
                    let low = input.low || [];
                    let close = input.close || [];
                    let tr = new TrueRange({ high: [], low: [], close: [] });
                    let wildersSmoothing = new WEMA({ period: period, values: [] });
                    this.generator = (function* () {
                        let tick = yield;
                        let atr;
                        while (true) {
                            let trueRange = tr.nextValue(tick);
                            if (trueRange !== undefined) {
                                atr = wildersSmoothing.nextValue(trueRange);
                            }
                            tick = yield atr;
                        }
                    })();
                    this.generator.next();
                    high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: low[index], close: close[index] };
                        const result = this.generator.next(tick);
                        if (result.value !== undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(tick) {
                    const result = this.generator.next(tick).value;
                    if (result !== undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    const trueRanges = TrueRange.calculate(input);
                    const wema = new WEMA({ period: input.period, values: trueRanges });
                    return wema.getResult();
                }
            }

            class ADX extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var high = input.high;
                    var low = input.low;
                    var close = input.close;
                    var atr = new(function() {
                        var lastValue;
                        var trueRange;
                        var atr;
                        var atrSma = new SMA({ period: period, values: [] });
                        this.nextValue = function(tick) {
                            if (lastValue === undefined) {
                                lastValue = tick;
                                return;
                            }
                            trueRange = Math.max(tick.high - tick.low, Math.abs(tick.high - lastValue.close), Math.abs(tick.low - lastValue.close));
                            lastValue = tick;
                            if (atr === undefined) {
                                atr = atrSma.nextValue(trueRange);
                            } else {
                                atr = (atr * (period - 1) + trueRange) / period;
                            }
                            return atr;
                        };
                    })();
                    var adx;
                    var pdi;
                    var mdi;
                    var pdiSma = new SMA({ period: period, values: [] });
                    var mdiSma = new SMA({ period: period, values: [] });
                    var adxSma = new SMA({ period: period, values: [] });
                    var lastTick;
                    this.generator = (function*() {
                        var tick = yield;
                        var result;
                        while (true) {
                            if (lastTick === undefined) {
                                lastTick = tick;
                                tick = yield;
                                continue;
                            }
                            var upMove = tick.high - lastTick.high;
                            var downMove = lastTick.low - tick.low;
                            var pdiValue = (upMove > downMove && upMove > 0) ? upMove : 0;
                            var mdiValue = (downMove > upMove && downMove > 0) ? downMove : 0;
                            lastTick = tick;
                            var atrValue = atr.nextValue(tick);
                            if (atrValue === undefined || atrValue === 0) {
                                tick = yield;
                                continue;
                            }
                            if (pdi === undefined) {
                                pdi = pdiSma.nextValue(100 * pdiValue / atrValue);
                                mdi = mdiSma.nextValue(100 * mdiValue / atrValue);
                                if (pdi === undefined) {
                                    tick = yield;
                                    continue;
                                }
                            } else {
                                pdi = (pdi * (period - 1) + 100 * pdiValue / atrValue) / period;
                                mdi = (mdi * (period - 1) + 100 * mdiValue / atrValue) / period;
                            }
                            var dx = (pdi + mdi === 0) ? 0 : 100 * Math.abs(pdi - mdi) / (pdi + mdi);
                            if (adx === undefined) {
                                adx = adxSma.nextValue(dx);
                            } else {
                                adx = (adx * (period - 1) + dx) / period;
                            }
                            if (adx != undefined) {
                                result = {
                                    adx: adx,
                                    pdi: pdi,
                                    mdi: mdi
                                };
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: low[index], close: close[index] };
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new ADX(input).getResult();
                }
            }

            exports.SMA = SMA;
            exports.EMA = EMA;
            exports.MACD = MACD;
            exports.RSI = RSI;
            exports.BollingerBands = BollingerBands;
            exports.ADX = ADX;
            exports.ATR = ATR;
            exports.TrueRange = TrueRange;
            exports.WEMA = WEMA;
            exports.Indicator = Indicator;

            Object.defineProperty(exports, '__esModule', { value: true });

        })));
    </script>
    
    <script type="module">
        // DOMContentLoaded olayƒ±, t√ºm HTML'nin y√ºklenip ayrƒ±≈ütƒ±rƒ±lmasƒ±nƒ± bekler
        window.addEventListener('DOMContentLoaded', () => {
            // K√ºt√ºphaneyi g√ºvenli bir ≈üekilde global scope'a atama
            const ti = window.technicalindicators;

            // G√ºvenlik kontrol√º: K√ºt√ºphane ve temel bir fonksiyon (RSI) var mƒ±?
            if (!ti || !ti.RSI) {
                console.error("KRƒ∞Tƒ∞K HATA: `technicalindicators` k√ºt√ºphanesi veya RSI fonksiyonu bulunamadƒ±. G√∂m√ºl√º kodda bir sorun olabilir.");
                const errorOverlay = document.getElementById('critical-error-overlay');
                if (errorOverlay) {
                    errorOverlay.classList.remove('hidden');
                    errorOverlay.classList.add('flex');
                }
                return; // Hata durumunda uygulamayƒ± ba≈ülatma
            }

            // --- UYGULAMA KODU ---
            const config = {
                coinList: ['AIUSDT', 'ALGOUSDT', 'ALICEUSDT', 'ALPINEUSDT', 'ALTUSDT', 'AMPUSDT', 'ANKRUSDT', 'APEUSDT', 'API3USDT', 'APTUSDT', 'ARBUSDT', 'ARKMUSDT', 'ARKUSDT', 'ARPAUSDT', 'ARUSDT', 'ASRUSDT', 'ATMUSDT', 'ATOMUSDT', 'AUCTIONUSDT', 'AUDIOUSDT', 'AVAXUSDT', 'AXLUSDT', 'AXSUSDT', 'BAKEUSDT', 'BARUSDT', 'BBUSDT', 'BCHUSDT', 'BEAMXUSDT', 'BELUSDT', 'BLURUSDT', 'BNBUSDT', 'BOMEUSDT', 'BONKUSDT', 'BTTCUSDT', 'CAKEUSDT', 'CELOUSDT', 'CFXUSDT', 'CHZUSDT', 'CITYUSDT', 'CKBUSDT', 'COMPUSDT', 'COTIUSDT', 'CRVUSDT', 'CYBERUSDT', 'DENTUSDT', 'DOGEUSDT', 'DOTUSDT', 'DYDXUSDT', 'DYMUSDT', 'EDUUSDT', 'EGLDUSDT', 'ENAUSDT', 'ENJUSDT', 'ENSUSDT', 'ETCUSDT', 'ETHFIUSDT', 'ETHUSDT', 'FETUSDT', 'FILUSDT', 'FLOKIUSDT', 'GALAUSDT', 'GRTUSDT', 'HBARUSDT', 'HIGHUSDT', 'HOTUSDT', 'ICPUSDT', 'IDUSDT', 'INJUSDT', 'IOUSDT', 'IOTAUSDT', 'JASMYUSDT', 'JTOUSDT', 'JUPUSDT', 'JUVUSDT', 'LDOUSDT', 'LINKUSDT', 'LISTAUSDT', 'LPTUSDT', 'LRCUSDT', 'LTCUSDT', 'LUNCUSDT', 'MAGICUSDT', 'MANAUSDT', 'MANTAUSDT', 'MASKUSDT', 'MAVUSDT', 'MEMEUSDT', 'METISUSDT', 'MINAUSDT', 'MKRUSDT', 'NEARUSDT', 'NEOUSDT', 'NFPUSDT', 'NOTUSDT', 'NTRNUSDT', 'OGNUSDT', 'OGUSDT', 'OMNIUSDT', 'OMUSDT', 'ONDOUSDT', 'OPUSDT', 'ORDIUSDT', 'PENDLEUSDT', 'PEOPLEUSDT', 'PEPEUSDT', 'PIXELUSDT', 'POLYXUSDT', 'PORTALUSDT', 'PORTOUSDT', 'PSGUSDT', 'PYTHUSDT', 'QTUMUSDT', 'RNDRUSDT', 'RONINUSDT', 'ROSEUSDT', 'RSRUSDT', 'SAGAUSDT', 'SANDUSDT', 'SANTOSUSDT', 'SEIUSDT', 'SHIBUSDT', 'SKLUSDT', 'SNXUSDT', 'SOLUSDT', 'STORJUSDT', 'STRKUSDT', 'STXUSDT', 'SUIUSDT', 'SUPERUSDT', 'SUSHIUSDT', 'TAOUSDT', 'THETAUSDT', 'TIAUSDT', 'TLMUSDT', 'TNSRUSDT', 'TONUSDT', 'TRBUSDT', 'TRUUSDT', 'TRXUSDT', 'TWTUSDT', 'UMAUSDT', 'UNIUSDT', 'USDCUSDT', 'USTCUSDT', 'VETUSDT', 'WIFUSDT', 'WLDUSDT', 'WUSDT', 'XAIUSDT', 'XLMUSDT', 'XRPUSDT', 'XVGUSDT', 'ZILUSDT', 'ZKUSDT', 'ZROUSDT'],
                scanInterval: 15000, 
                cacheDuration: 1000 * 60 * 15, // 15 dakika
            };
            const UIElements = {
                coinList: document.getElementById('coin-list'),
                signalsGrid: document.getElementById('signals-grid'),
                stats: { total: document.getElementById('total-signals'), successful: document.getElementById('successful-signals'), stopped: document.getElementById('stopped-signals'), rate: document.getElementById('success-rate'), },
                modal: { container: document.getElementById('details-modal'), title: document.getElementById('modal-title'), content: document.getElementById('modal-content'), closeButton: document.getElementById('close-modal'), },
                connectionStatus: document.getElementById('connection-status'),
                coinSearch: document.getElementById('coin-search'),
                placeholderCard: document.getElementById('placeholder-card'),
                terminal: {
                    output: document.getElementById('terminal-output'),
                    progress: document.getElementById('terminal-progress-indicator'),
                }
            };
            let state = { coinsData: {}, activeSignals: {}, signalStats: { total: 0, successful: 0, stopped: 0 }, currentScanIndex: 0, klinesCache: new Map(), webSocket: null, indicatorSettings: {}, priorityList: [] };
            
            const terminalManager = {
                log(message, type = 'info') {
                    const now = new Date();
                    const timeString = now.toTimeString().split(' ')[0];
                    const p = document.createElement('p');
                    let icon = '';
                    let colorClass = '';
                    switch(type) {
                        case 'scan': icon = 'üîç'; colorClass = 'log-scan'; break;
                        case 'success': icon = '‚úÖ'; colorClass = 'log-success'; break;
                        case 'error': icon = '‚ùå'; colorClass = 'log-error'; break;
                        default: icon = '‚ÑπÔ∏è'; colorClass = 'log-info';
                    }
                    p.innerHTML = `<span class="icon">${icon}</span> <span>[${timeString}] ${message}</span>`;
                    p.className = colorClass;
                    UIElements.terminal.output.appendChild(p);
                    UIElements.terminal.output.scrollTop = UIElements.terminal.output.scrollHeight;
                },
                updateProgress(currentIndex, total) {
                    const percentage = total > 0 ? ((currentIndex / total) * 100) : 0;
                    UIElements.terminal.progress.style.width = `${percentage.toFixed(2)}%`;
                    UIElements.terminal.progress.textContent = `${percentage.toFixed(0)}%`;
                }
            };

            const apiManager = {
                baseUrl: 'https://api.binance.com/api/v3',
                async get24hTickers() { try { const response = await fetch(`${this.baseUrl}/ticker/24hr`); if (!response.ok) throw new Error(`API Error: ${response.status}`); return await response.json(); } catch (error) { console.error("Ticker verileri alƒ±namadƒ±:", error); terminalManager.log('Piyasa verileri alƒ±namadƒ±.', 'error'); return []; } },
                async getKlines(symbol, interval, limit = 200) { const cacheKey = `${symbol}_${interval}`; const cached = state.klinesCache.get(cacheKey); if (cached && (Date.now() - cached.timestamp < config.cacheDuration)) { return cached.data; } try { const response = await fetch(`${this.baseUrl}/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`); if (!response.ok) throw new Error(`API Error: ${response.status}`); const data = await response.json(); state.klinesCache.set(cacheKey, { data, timestamp: Date.now() }); return data; } catch (error) { console.error(`${symbol} i√ßin ${interval} klines verisi alƒ±namadƒ±:`, error); terminalManager.log(`${symbol} i√ßin veri alƒ±namadƒ±.`, 'error'); return null; } }
            };

            const indicatorCalculator = {
                initializeSettings(symbol) { 
                    if (!state.indicatorSettings[symbol]) { 
                        state.indicatorSettings[symbol] = { 
                            rsiPeriod: 14, 
                            macd: { fastPeriod: 12, slowPeriod: 26, signalPeriod: 9 }, 
                            bbPeriod: 20, 
                            adxPeriod: 14,
                            atrPeriod: 14
                        }; 
                    } 
                },
                calculateAll(symbol, klines) { 
                    if (!klines || klines.length < 30) return null; 
                    this.initializeSettings(symbol); 
                    const settings = state.indicatorSettings[symbol]; 
                    
                    const inputs = {
                        open: klines.map(k => parseFloat(k[1])),
                        high: klines.map(k => parseFloat(k[2])),
                        low: klines.map(k => parseFloat(k[3])),
                        close: klines.map(k => parseFloat(k[4])),
                        volume: klines.map(k => parseFloat(k[5])),
                    };

                    const calculateVWAP = (klines) => {
                        let cumulativePV = 0;
                        let cumulativeVolume = 0;
                        klines.forEach(k => {
                            const high = parseFloat(k[2]);
                            const low = parseFloat(k[3]);
                            const close = parseFloat(k[4]);
                            const volume = parseFloat(k[5]);
                            const typicalPrice = (high + low + close) / 3;
                            cumulativePV += typicalPrice * volume;
                            cumulativeVolume += volume;
                        });
                        return cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : 0;
                    };

                    const getMarketStructure = (klines) => {
                        const recentKlines = klines.slice(-10); // Son 10 muma bak
                        const highs = recentKlines.map(k => parseFloat(k[2]));
                        const lows = recentKlines.map(k => parseFloat(k[3]));
                        
                        if(highs.length < 3) return "Belirsiz";

                        const lastHigh = highs[highs.length - 1];
                        const prevHigh = Math.max(...highs.slice(0, highs.length - 2));
                        const lastLow = lows[lows.length - 1];
                        const prevLow = Math.min(...lows.slice(0, lows.length - 2));

                        if (lastHigh > prevHigh && lastLow > prevLow) return "Y√ºkseli≈ü Trendi (HH/HL)";
                        if (lastHigh < prevHigh && lastLow < prevLow) return "D√º≈ü√º≈ü Trendi (LH/LL)";
                        return "Yatay Piyasa";
                    };

                    try { 
                        const vwap = calculateVWAP(klines);
                        const vwapDeviation = vwap > 0 ? ((inputs.close[inputs.close.length - 1] - vwap) / vwap * 100).toFixed(2) : 0;
                        const marketStructure = getMarketStructure(klines);
                        
                        return { 
                            rsi: ti.RSI.calculate({ values: inputs.close, period: settings.rsiPeriod }).pop()?.toFixed(2), 
                            macd: ti.MACD.calculate({ ...settings.macd, values: inputs.close, SimpleMAOscillator: false, SimpleMASignal: false }).pop(), 
                            bb: ti.BollingerBands.calculate({ period: settings.bbPeriod, values: inputs.close, stdDev: 2 }).pop(), 
                            adx: ti.ADX.calculate({ period: settings.adxPeriod, high: inputs.high, low: inputs.low, close: inputs.close }).pop(),
                            atr: ti.ATR.calculate({ period: settings.atrPeriod, high: inputs.high, low: inputs.low, close: inputs.close }).pop()?.toFixed(4),
                            vwapDeviation: vwapDeviation,
                            marketStructure: marketStructure
                        }; 
                    } catch (error) { 
                        console.error(`${symbol} i√ßin indikat√∂r hesaplama hatasƒ±:`, error); 
                        terminalManager.log(`${symbol} indikat√∂r hatasƒ±.`, 'error');
                        return null; 
                    } 
                },
            };

            const aiCore = {
                createPrompt(symbol, price, data) { 
                    const formatIndicators = (indicators) => { 
                        if (!indicators) return "Hesaplanamadƒ±."; 
                        const macdHistogram = indicators.macd && indicators.macd.histogram ? indicators.macd.histogram.toFixed(4) : "N/A";
                        const adxValue = indicators.adx && indicators.adx.adx ? indicators.adx.adx.toFixed(2) : "N/A";
                        return `RSI: ${indicators.rsi}, MACD Hist: ${macdHistogram}, ADX: ${adxValue}`; 
                    }; 
                    const btcContext = `4s BTC Trendi: ${data.btc.trend}, 4s BTC RSI: ${data.btc.rsi}`; 
                    return `Sen, d√ºnya standartlarƒ±nda, elit bir kantitatif trader asistanƒ±sƒ±n. G√∂revin, sana saƒülanan √ßok √ße≈üitli teknik ve yapƒ±sal verileri analiz ederek, y√ºksek olasƒ±lƒ±klƒ±, ger√ßek√ßi ve kƒ±sa vadeli 'AL' sinyalleri √ºretmektir. Sadece veriye dayalƒ±, matematiksel ve profesyonel kararlar ver.
                        Pƒ∞YASA GENEL DURUMU (BTC): ${btcContext}
                        ANALƒ∞Z EDƒ∞LECEK COIN: ${symbol}
                        MEVCUT Fƒ∞YAT: ${price}
                        ƒ∞≈ûLENMƒ∞≈û TEKNƒ∞K VERƒ∞LER:
                        - 15 Dakikalƒ±k ƒ∞ndikat√∂rler: ${formatIndicators(data.indicators.m15)}
                        - 1 Saatlik ƒ∞ndikat√∂rler: ${formatIndicators(data.indicators.h1)}
                        - 4 Saatlik ƒ∞ndikat√∂rler: ${formatIndicators(data.indicators.h4)}
                        - 1 G√ºnl√ºk ƒ∞ndikat√∂rler: ${formatIndicators(data.indicators.d1)}
                        YAPISAL VERƒ∞LER:
                        - 4s Piyasa Yapƒ±sƒ± (Son 10 mum): ${data.indicators.h4?.marketStructure}
                        - 4s VWAP Sapmasƒ± (%): ${data.indicators.h4?.vwapDeviation}
                        - G√ºnl√ºk Volatilite (ATR): ${data.indicators.d1?.atr}
                        G√ñREV: Yukarƒ±daki teknik ve yapƒ±sal verileri b√ºt√ºnsel olarak analiz et. ${symbol} i√ßin bir 'AL' sinyali olu≈üturmanƒ±n mantƒ±klƒ± olup olmadƒ±ƒüƒ±nƒ± deƒüerlendir. Cevabƒ±nƒ± MUTLAKA a≈üaƒüƒ±daki JSON formatƒ±nda ver. A√ßƒ±klama ekleme, sadece JSON √ßƒ±ktƒ±sƒ± ver.
                        {
                          "shouldSignal": boolean,
                          "confidenceScore": number,
                          "analysisRationale": "Karar s√ºrecini, sana verdiƒüim t√ºm indikat√∂rlere (RSI, MACD, ADX), piyasa yapƒ±sƒ±na, VWAP sapmasƒ±na ve BTC durumuna atƒ±fta bulunarak detaylƒ±ca a√ßƒ±kla. Farklƒ± zaman dilimlerindeki uyum veya uyumsuzluklarƒ± belirt. √ñrneƒüin: '4 saatlik grafikte Y√ºkseli≈ü Trendi (HH/HL) yapƒ±sƒ± teyit edildi. Fiyat, VWAP'ƒ±n %2 altƒ±nda, bu da potansiyel bir alƒ±m fƒ±rsatƒ±na i≈üaret ediyor. MACD pozitif b√∂lgeye ge√ßmi≈ü ve g√ºnl√ºk ADX trendin g√º√ßlendiƒüini g√∂steriyor. Bitcoin'in de y√ºkseli≈ü trendinde olmasƒ± bu sinyali g√º√ßlendiriyor. Stop-loss seviyesi, g√ºnl√ºk ATR deƒüeri ve bir √∂nceki dip seviyesi dikkate alƒ±narak belirlenmi≈ütir.'",
                          "targets": { "tp1": number, "tp2": number },
                          "stopLoss": number
                        }
                        HEDEF BELƒ∞RLEME KURALLARI (√áOK √ñNEMLƒ∞):
                        1. Ger√ßek√ßi ve Ula≈üƒ±labilir Ol: Hedefler hayali olmamalƒ±. Kƒ±sa vadeli (saatlik/g√ºnl√ºk) hedefler belirle.
                        2. TP1 (Hedef 1): En yakƒ±n ve bariz likidite (diren√ß) b√∂lgesi olmalƒ±. Fiyatƒ±n zorlanmadan ula≈üabileceƒüi ilk mantƒ±klƒ± seviye.
                        3. TP2 (Hedef 2): Daha g√º√ßl√º, bir √ºstteki diren√ß b√∂lgesi olmalƒ±. TP1'in kƒ±rƒ±lmasƒ± durumunda potansiyel hedef.
                        4. Stop Loss (SL): Fiyat yapƒ±sƒ±nƒ± bozacak en yakƒ±n ve en mantƒ±klƒ± destek seviyesinin hemen altƒ± olmalƒ±. ƒ∞≈ülemin ge√ßersiz olacaƒüƒ± seviyeyi doƒüru belirle.
                        5. Risk/Kazan√ß Oranƒ±: Belirlediƒüin hedeflerin, SL'e g√∂re makul bir risk/kazan√ß oranƒ± sunduƒüundan emin ol.
                        GENEL KURALLAR:
                        - 'shouldSignal' sadece t√ºm veriler g√º√ßl√º bir y√ºkseli≈ü potansiyeli g√∂sterdiƒüinde ve BTC durumu riskli deƒüilse 'true' olmalƒ±.
                        - 'confidenceScore' (1-10 arasƒ±) sinyale olan g√ºvenini belirtmeli. 7'den d√º≈ü√ºkse sinyal √ºretme.
                        - 'analysisRationale' ≈üeffaf, veriye dayalƒ± ve profesyonel olmalƒ±.
                        `; 
                },
                async analyzeCoin(symbol, price, data) {
                    const userPrompt = this.createPrompt(symbol, price, data);
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: userPrompt }] }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "shouldSignal": { "type": "BOOLEAN" },
                                    "confidenceScore": { "type": "NUMBER" },
                                    "analysisRationale": { "type": "STRING" },
                                    "targets": {
                                        "type": "OBJECT",
                                        properties: {
                                            "tp1": { "type": "NUMBER" },
                                            "tp2": { "type": "NUMBER" }
                                        },
                                        required: ["tp1", "tp2"]
                                    },
                                    "stopLoss": { "type": "NUMBER" }
                                },
                                required: ["shouldSignal", "confidenceScore", "analysisRationale", "targets", "stopLoss"]
                            }
                        }
                    };
                    const apiKey = ""; // Canvas ortamƒ± i√ßin bo≈ü bƒ±rakƒ±n
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error("Gemini API Hata Yanƒ±tƒ±:", errorText);
                            throw new Error(`Gemini API Hatasƒ±: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        if (result.candidates && result.candidates[0]?.content?.parts[0]) {
                            const text = result.candidates[0].content.parts[0].text;
                            try {
                                return JSON.parse(text);
                            } catch (e) {
                                console.error("Gemini yanƒ±tƒ±ndan JSON ayrƒ±≈ütƒ±rƒ±lamadƒ±:", text, e);
                                terminalManager.log(`${symbol} AI yanƒ±tƒ± anla≈üƒ±lamadƒ±.`, 'error');
                                return null;
                            }
                        } else {
                            console.error("Beklenmedik Gemini API yanƒ±t yapƒ±sƒ±:", result);
                            terminalManager.log(`${symbol} AI'dan beklenmedik yanƒ±t.`, 'error');
                            return null;
                        }
                    } catch (error) {
                        console.error("Gemini analizi ba≈üarƒ±sƒ±z:", error);
                        terminalManager.log(`${symbol} AI analizi ba≈üarƒ±sƒ±z.`, 'error');
                        uiManager.setScanStatus(symbol, "Analiz Hatasƒ±!");
                        return null;
                    }
                }
            };

            const uiManager = {
                updateCoinList() { const sortedCoins = Object.values(state.coinsData).filter(c => config.coinList.includes(c.s)).sort((a, b) => parseFloat(b.P) - parseFloat(a.P)); UIElements.coinList.innerHTML = ''; const searchTerm = UIElements.coinSearch.value.toLowerCase(); sortedCoins.filter(coin => coin.s.toLowerCase().includes(searchTerm)).forEach(coin => { const price = parseFloat(coin.c).toFixed(Math.max(2, (coin.c.split('.')[1] || '').length)); const change = parseFloat(coin.P); const changeColor = change >= 0 ? 'text-green-400' : 'text-red-400'; const coinEl = document.createElement('div'); coinEl.id = `coin-${coin.s}`; coinEl.className = 'flex justify-between items-center p-2 rounded-lg hover:bg-gray-800/50 transition-colors cursor-pointer'; coinEl.innerHTML = `<div class="flex items-center gap-3"><img src="https://s2.coinmarketcap.com/static/img/coins/64x64/${coin.s.replace('USDT', '').toLowerCase()}.png" onerror="this.onerror=null;this.src='https://placehold.co/32x32/161b22/c9d1d9?text=${coin.s[0]}';" alt="${coin.s}" class="w-8 h-8 rounded-full"><div><p class="font-bold text-sm text-white">${coin.s.replace('USDT', '')}</p><p class="text-xs text-gray-400" id="price-${coin.s}">$${price}</p></div></div><div class="text-right"><p class="font-semibold text-sm ${changeColor}">${change.toFixed(2)}%</p><p class="text-xs text-gray-500" id="status-${coin.s}"></p></div>`; UIElements.coinList.appendChild(coinEl); }); },
                updateLivePrice(data) { 
                    const newPrice = parseFloat(data.c);
                    const formattedPrice = newPrice.toFixed(Math.max(2, (data.c.split('.')[1] || '').length));

                    // Sol taraftaki liste fiyatƒ±nƒ± g√ºncelle
                    const priceEl = document.getElementById(`price-${data.s}`); 
                    if (priceEl) { 
                        const oldPrice = parseFloat(priceEl.innerText.replace('$', '')); 
                        const priceColor = newPrice > oldPrice ? 'text-green-400' : newPrice < oldPrice ? 'text-red-400' : 'text-gray-400'; 
                        priceEl.innerText = `$${formattedPrice}`; 
                        priceEl.classList.remove('text-green-400', 'text-red-400', 'text-gray-400'); 
                        priceEl.classList.add(priceColor); 
                        setTimeout(() => priceEl.classList.remove(priceColor), 500); 
                    }

                    // Aktif sinyal kartƒ± varsa onu da g√ºncelle
                    if(state.activeSignals[data.s]) {
                        this.updateSignalProgressBar(data.s, newPrice);
                        
                        const signalPriceEl = document.getElementById(`live-price-signal-${data.s}`);
                        if (signalPriceEl) {
                            const oldPrice = parseFloat(signalPriceEl.textContent);
                            const priceColor = newPrice > oldPrice ? 'text-green-400' : newPrice < oldPrice ? 'text-red-400' : 'text-gray-300';
                            signalPriceEl.textContent = formattedPrice;
                            signalPriceEl.classList.remove('text-green-400', 'text-red-400', 'text-gray-300');
                            signalPriceEl.classList.add(priceColor);
                        }
                    }
                },
                setScanStatus(symbol, text) { const statusEl = document.getElementById(`status-${symbol}`); if (statusEl) { statusEl.innerHTML = `<span class="blinking">${text}</span>`; } },
                createSignalCard(symbol, signalData, entryPrice) { 
                    if (UIElements.placeholderCard) { UIElements.placeholderCard.remove(); UIElements.placeholderCard = null; } 
                    
                    const tp1_profit_pct = ((signalData.targets.tp1 - entryPrice) / entryPrice * 100).toFixed(2);
                    const tp2_profit_pct = ((signalData.targets.tp2 - entryPrice) / entryPrice * 100).toFixed(2);
                    const sl_loss_pct = ((signalData.stopLoss - entryPrice) / entryPrice * 100).toFixed(2);

                    const signalId = `signal-${symbol}-${Date.now()}`; 
                    const card = document.createElement('div'); 
                    card.id = signalId; 
                    card.className = 'signal-card glass-effect rounded-lg p-4 flex flex-col space-y-3 border-l-emerald-500'; 
                    card.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2">
                                <img src="https://s2.coinmarketcap.com/static/img/coins/64x64/${symbol.replace('USDT', '').toLowerCase()}.png" onerror="this.onerror=null;this.src='https://placehold.co/24x24/161b22/c9d1d9?text=${symbol[0]}';" alt="${symbol}" class="w-6 h-6 rounded-full">
                                <h4 class="text-lg font-bold text-white">${symbol.replace('USDT','')}</h4>
                                <span id="live-price-signal-${symbol}" class="font-mono text-lg text-gray-300 ml-2">${parseFloat(entryPrice).toFixed(Math.max(2, (entryPrice.split('.')[1] || '').length))}</span>
                            </div>
                            <div class="px-2 py-1 rounded text-xs font-bold bg-emerald-500/20 text-emerald-300">G√ºven: ${signalData.confidenceScore}/10</div>
                        </div>
                        <div id="status-box-${signalId}" class="text-center p-2 rounded-lg bg-gray-800/60">
                            <p class="text-sm font-medium text-yellow-300">AKTƒ∞F</p>
                            <p class="text-xs text-gray-400">Hedefler bekleniyor</p>
                        </div>
                        <div class="grid grid-cols-3 gap-x-4 gap-y-2 text-sm">
                            <div class="text-gray-400">Giri≈ü Fiyatƒ±</div>
                            <div class="text-right font-mono text-white col-span-2">${entryPrice}</div>

                            <div class="text-gray-400">Hedef 1 (TP1)</div>
                            <div class="text-right font-mono text-green-400">${signalData.targets.tp1}</div>
                            <div class="text-right font-mono text-green-500">(+${tp1_profit_pct}%)</div>

                            <div class="text-gray-400">Hedef 2 (TP2)</div>
                            <div class="text-right font-mono text-green-300">${signalData.targets.tp2}</div>
                            <div class="text-right font-mono text-green-400">(+${tp2_profit_pct}%)</div>

                            <div class="text-gray-400">Stop Loss (SL)</div>
                            <div class="text-right font-mono text-red-400">${signalData.stopLoss}</div>
                            <div class="text-right font-mono text-red-500">(${sl_loss_pct}%)</div>
                        </div>
                        <div class="mt-2">
                            <div class="price-progress-bar" id="progress-bar-${signalId}">
                                <div class="price-indicator" id="price-indicator-${signalId}"></div>
                            </div>
                        </div>
                        <button data-symbol="${symbol}" data-rationale="${encodeURIComponent(signalData.analysisRationale)}" class="details-btn mt-2 w-full bg-blue-600/50 hover:bg-blue-600/80 text-white text-sm font-semibold py-2 rounded-lg transition-colors">Analiz Detaylarƒ±</button>`; 
                    UIElements.signalsGrid.prepend(card); 
                    this.updateStats(true); 
                    state.activeSignals[symbol] = { ...signalData, id: signalId, status: 'active', entryPrice: parseFloat(entryPrice) }; 
                    this.updateSignalProgressBar(symbol, parseFloat(entryPrice));
                },
                updateSignalProgressBar(symbol, currentPrice) {
                    const signal = state.activeSignals[symbol];
                    if (!signal) return;

                    const progressBar = document.getElementById(`progress-bar-${signal.id}`);
                    const priceIndicator = document.getElementById(`price-indicator-${signal.id}`);

                    if (!progressBar || !priceIndicator) return;

                    const { stopLoss, targets } = signal;
                    const tp2 = targets.tp2;

                    const totalRange = tp2 - stopLoss;
                    if (totalRange <= 0) return;

                    const currentProgress = currentPrice - stopLoss;
                    let progressPct = (currentProgress / totalRange) * 100;
                    
                    // √áubuƒüun %0 ile %100 arasƒ±nda kalmasƒ±nƒ± saƒüla
                    progressPct = Math.max(0, Math.min(100, progressPct));

                    priceIndicator.style.left = `${progressPct}%`;
                },
                updateSignalStatus(symbol, status) { const signal = state.activeSignals[symbol]; if (!signal || signal.status !== 'active') return; signal.status = status; const statusBox = document.getElementById(`status-box-${signal.id}`); if (statusBox) { if (status === 'successful') { statusBox.innerHTML = `<p class="text-sm font-medium text-green-400">BA≈ûARILI</p><p class="text-xs text-gray-400">Hedefe ula≈üƒ±ldƒ±!</p>`; statusBox.parentElement.classList.remove('border-l-emerald-500'); statusBox.parentElement.classList.add('border-l-green-400'); this.updateStats(false, true, false); } else if (status === 'stopped') { statusBox.innerHTML = `<p class="text-sm font-medium text-red-400">STOP OLDU</p><p class="text-xs text-gray-400">Stop seviyesine ula≈üƒ±ldƒ±.</p>`; statusBox.parentElement.classList.remove('border-l-emerald-500'); statusBox.parentElement.classList.add('border-l-red-400'); this.updateStats(false, false, true); } } delete state.activeSignals[symbol]; },
                updateStats(isNew = false, isSuccess = false, isStop = false) {
                    if (isNew) state.signalStats.total++;
                    if (isSuccess) state.signalStats.successful++;
                    if (isStop) state.signalStats.stopped++;

                    UIElements.stats.total.textContent = state.signalStats.total;
                    UIElements.stats.successful.textContent = state.signalStats.successful;
                    UIElements.stats.stopped.textContent = state.signalStats.stopped;

                    const concludedSignals = state.signalStats.successful + state.signalStats.stopped;
                    if (concludedSignals > 0) {
                        const successRate = (state.signalStats.successful / concludedSignals) * 100;
                        UIElements.stats.rate.textContent = `${successRate.toFixed(1)}%`;
                    } else {
                        UIElements.stats.rate.textContent = 'N/A';
                    }
                },
                toggleModal(show, title = '', content = '') { if (show) { UIElements.modal.title.textContent = `${title.replace('USDT','')} Analiz Detaylarƒ±`; UIElements.modal.content.innerHTML = `<p>${decodeURIComponent(content).replace(/\n/g, '<br>')}</p>`; UIElements.modal.container.classList.remove('hidden'); UIElements.modal.container.classList.add('flex'); } else { UIElements.modal.container.classList.add('hidden'); UIElements.modal.container.classList.remove('flex');} },
                setConnectionStatus(connected) { const dot = UIElements.connectionStatus.querySelector('.status-dot'); const text = UIElements.connectionStatus.querySelector('span'); if(connected){ dot.classList.remove('bg-yellow-400', 'bg-red-400'); dot.classList.add('bg-green-400'); text.textContent = 'Baƒülandƒ±'; } else { dot.classList.remove('bg-green-400'); dot.classList.add('bg-red-400'); text.textContent = 'Baƒülantƒ± Kesildi'; } }
            };

            const App = {
                async init() { 
                    terminalManager.log('Uygulama ba≈ülatƒ±lƒ±yor...');
                    const tickers = await apiManager.get24hTickers(); 
                    terminalManager.log('Piyasa verileri alƒ±ndƒ±.');
                    tickers.forEach(t => { if (config.coinList.includes(t.symbol)) { state.coinsData[t.symbol] = { s: t.symbol, c: t.lastPrice, P: t.priceChangePercent, q: t.quoteVolume }; } }); 
                    uiManager.updateCoinList(); 
                    this.setupEventListeners(); 
                    this.startWebSocket(); 
                    setTimeout(() => this.scanLoop(), 2000); 
                },
                updatePriorityList() {
                    terminalManager.log('Piyasa analiz ediliyor ve √∂ncelik listesi olu≈üturuluyor...');
                    const allCoins = Object.values(state.coinsData).filter(c => c && config.coinList.includes(c.s));

                    const scoredCoins = allCoins
                        .map(coin => {
                            const priceChange = parseFloat(coin.P);
                            const volume = parseFloat(coin.q);
                            if (priceChange <= 0 || volume <= 0 || !isFinite(volume)) {
                                return { s: coin.s, score: -Infinity };
                            }
                            const score = priceChange * Math.log10(volume);
                            return { s: coin.s, score };
                        })
                        .filter(coin => isFinite(coin.score))
                        .sort((a, b) => b.score - a.score);

                    state.priorityList = scoredCoins.slice(0, 50).map(c => c.s);
                    terminalManager.log(`√ñncelikli ${state.priorityList.length} coin belirlendi. Tarama ba≈ülƒ±yor.`, 'success');
                },
                setupEventListeners() { UIElements.coinSearch.addEventListener('input', () => uiManager.updateCoinList()); UIElements.modal.closeButton.addEventListener('click', () => uiManager.toggleModal(false)); UIElements.signalsGrid.addEventListener('click', (e) => { const button = e.target.closest('.details-btn'); if (button) { const { symbol, rationale } = button.dataset; uiManager.toggleModal(true, symbol, rationale); } }); },
                startWebSocket() { 
                    terminalManager.log('Canlƒ± veri akƒ±≈üƒ±na baƒülanƒ±lƒ±yor...');
                    const streams = config.coinList.map(s => `${s.toLowerCase()}@ticker`).join('/'); 
                    if (state.webSocket) { state.webSocket.close(); }
                    state.webSocket = new WebSocket(`wss://stream.binance.com:9443/ws/${streams}`); 
                    state.webSocket.onopen = () => { uiManager.setConnectionStatus(true); terminalManager.log('Canlƒ± veri akƒ±≈üƒ± aktif!', 'success'); }; 
                    state.webSocket.onmessage = (event) => { 
                        const data = JSON.parse(event.data); 
                        if (data.e === '24hrTicker') { 
                            if(state.coinsData[data.s]) { 
                                state.coinsData[data.s].c = data.c; 
                                state.coinsData[data.s].P = data.P; 
                                state.coinsData[data.s].q = data.q; 
                            } 
                            uiManager.updateLivePrice(data); 
                            this.checkActiveSignals(data.s, parseFloat(data.c)); 
                        } 
                    }; 
                    state.webSocket.onclose = () => { uiManager.setConnectionStatus(false); terminalManager.log('Canlƒ± veri baƒülantƒ±sƒ± kesildi. 5 saniye i√ßinde yeniden denenecek...', 'error'); setTimeout(() => this.startWebSocket(), 5000); }; 
                    state.webSocket.onerror = (error) => { console.error("WebSocket Hatasƒ±:", error); uiManager.setConnectionStatus(false); state.webSocket.close(); }; 
                },
                checkActiveSignals(symbol, price) { const signal = state.activeSignals[symbol]; if (signal && signal.status === 'active') { if (price >= signal.targets.tp2) { terminalManager.log(`${symbol} t√ºm hedeflere ula≈ütƒ±! (TP2)`, 'success'); uiManager.updateSignalStatus(symbol, 'successful'); } else if (price >= signal.targets.tp1) { const statusBox = document.getElementById(`status-box-${signal.id}`); if(statusBox && !statusBox.innerText.includes("TP1 BA≈ûARILI")) { terminalManager.log(`${symbol} hedef 1'e ula≈ütƒ±! (TP1)`, 'success'); statusBox.innerHTML = `<p class="text-sm font-medium text-cyan-300">TP1 BA≈ûARILI</p><p class="text-xs text-gray-400">TP2 bekleniyor</p>`; } } else if (price <= signal.stopLoss) { terminalManager.log(`${symbol} stop oldu.`, 'error'); uiManager.updateSignalStatus(symbol, 'stopped'); } } },
                async scanLoop() {
                    if (state.currentScanIndex === 0 || state.currentScanIndex >= state.priorityList.length) {
                        if (state.currentScanIndex >= state.priorityList.length) {
                            terminalManager.log('√ñncelik listesi taramasƒ± tamamlandƒ±. Liste g√ºncelleniyor.');
                        }
                        state.currentScanIndex = 0;
                        this.updatePriorityList();
                        
                        if (state.priorityList.length === 0) {
                            terminalManager.log('Analiz edilecek √∂ncelikli coin bulunamadƒ±. Tekrar denenecek.', 'error');
                            setTimeout(() => this.scanLoop(), config.scanInterval * 2);
                            return;
                        }
                    }
                    
                    terminalManager.updateProgress(state.currentScanIndex + 1, state.priorityList.length);

                    const symbol = state.priorityList[state.currentScanIndex];
                    const coinToScan = state.coinsData[symbol];

                    if (!coinToScan) {
                        console.error(`√ñncelik listesindeki ${symbol} i√ßin veri bulunamadƒ±.`);
                        state.currentScanIndex++;
                        setTimeout(() => this.scanLoop(), 1000);
                        return;
                    }

                    if (!state.activeSignals[symbol]) {
                        uiManager.setScanStatus(symbol, "Analiz ediliyor...");
                        terminalManager.log(`${symbol} analiz ediliyor...`, 'scan');
                        
                        const btcKlines = await apiManager.getKlines('BTCUSDT', '4h');
                        const btcIndicators = indicatorCalculator.calculateAll('BTCUSDT', btcKlines);
                        
                        if (btcIndicators) {
                            const klines = {
                                m15: await apiManager.getKlines(symbol, '15m'),
                                h1: await apiManager.getKlines(symbol, '1h'),
                                h4: await apiManager.getKlines(symbol, '4h'),
                                d1: await apiManager.getKlines(symbol, '1d'),
                            };
                            const indicators = {
                                m15: indicatorCalculator.calculateAll(symbol, klines.m15),
                                h1: indicatorCalculator.calculateAll(symbol, klines.h1),
                                h4: indicatorCalculator.calculateAll(symbol, klines.h4),
                                d1: indicatorCalculator.calculateAll(symbol, klines.d1),
                            };
                            if (Object.values(indicators).every(d => d !== null)) {
                                const analysisData = {
                                    indicators: indicators,
                                    btc: {
                                        rsi: btcIndicators.rsi,
                                        trend: btcIndicators.macd.histogram > 0 ? 'Y√ºkseli≈ü' : 'D√º≈ü√º≈ü'
                                    }
                                };
                                const analysisResult = await aiCore.analyzeCoin(symbol, coinToScan.c, analysisData);
                                if (analysisResult && analysisResult.shouldSignal && analysisResult.confidenceScore >= 7) {
                                    uiManager.createSignalCard(symbol, analysisResult, coinToScan.c);
                                    terminalManager.log(`${symbol} i√ßin yeni sinyal bulundu!`, 'success');
                                }
                            }
                        }
                    }
                    uiManager.setScanStatus(symbol, "");
                    state.currentScanIndex++;
                    setTimeout(() => this.scanLoop(), config.scanInterval);
                },
            };
            
            App.init();
        });
    </script>
</body>
</html>
