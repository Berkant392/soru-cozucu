<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini AI Kripto Sinyal Asistanı v2.5 (Gelişmiş Sürüm)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0d1117; color: #c9d1d9; }
        .glass-effect { background: rgba(22, 27, 34, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(48, 54, 61, 0.5); }
        .signal-card { transition: all 0.3s ease; border-left-width: 4px; }
        .signal-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .blinking { animation: blink 1.5s linear infinite; }
        @keyframes blink { 50% { opacity: 0.4; } }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #161b22; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #485058; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

        /* Terminal Stilleri */
        #ai-terminal {
            font-family: 'Roboto Mono', monospace;
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 380px;
            max-width: 90vw;
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            color: #c9d1d9;
            z-index: 100;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .terminal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background-color: #21262d;
            border-bottom: 1px solid #30363d;
        }
        .terminal-header .dots { display: flex; gap: 0.5rem; }
        .terminal-header .dot { width: 12px; height: 12px; border-radius: 50%; }
        .terminal-header .dot-red { background-color: #ff5f56; }
        .terminal-header .dot-yellow { background-color: #ffbd2e; }
        .terminal-header .dot-green { background-color: #27c93f; }
        .terminal-header .title { font-weight: 500; color: #f0f6fc; font-size: 0.9rem; }
        .terminal-header .status { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; color: #27c93f; }
        .terminal-header .status-indicator { width: 8px; height: 8px; background-color: #27c93f; border-radius: 50%; animation: blink 1.5s linear infinite; }
        .terminal-body { padding: 0.75rem; height: 120px; overflow-y: auto; font-size: 0.8rem; }
        .terminal-body p { margin-bottom: 0.5rem; display: flex; align-items: flex-start; }
        .terminal-body p .icon { margin-right: 0.5rem; margin-top: 2px; }
        .terminal-body .log-info { color: #58a6ff; }
        .terminal-body .log-success { color: #3fb950; }
        .terminal-body .log-scan { color: #a371f7; }
        .terminal-body .log-error { color: #f85149; }
        .terminal-progress-bar {
            width: calc(100% - 1.5rem);
            margin: 0 0.75rem 0.75rem 0.75rem;
            height: 18px;
            background-color: #0d1117;
            border-radius: 0.375rem;
            overflow: hidden;
            border: 1px solid #30363d;
        }
        .terminal-progress {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #27c93f, #3fb950);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            color: #ffffff;
        }
        /* Dinamik Fiyat Çubuğu Stilleri */
        .price-progress-bar {
            background: linear-gradient(to right, #ef4444, #f59e0b, #84cc16);
            border-radius: 0.25rem;
            height: 8px;
            position: relative;
            margin-top: 4px;
        }
        .price-indicator {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 12px;
            background-color: #ffffff;
            border-radius: 2px;
            transform: translateX(-50%);
            transition: left 0.5s ease;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="main-container" class="flex flex-col lg:flex-row h-screen max-h-screen p-4 gap-4">
        <aside class="w-full lg:w-1/4 xl:w-1/5 flex flex-col glass-effect rounded-2xl p-4 space-y-4">
            <div class="flex items-center justify-between"><h2 class="text-xl font-bold text-white">Piyasa</h2><div id="connection-status" class="flex items-center gap-2 text-xs"><div class="status-dot bg-yellow-400"></div><span>Bağlanıyor...</span></div></div>
            <div class="relative"><input type="text" id="coin-search" placeholder="Coin Ara..." class="w-full bg-[#0d1117] border border-gray-700 rounded-lg px-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500"></div>
            <div id="coin-list" class="flex-grow overflow-y-auto pr-2"></div>
        </aside>
        <main class="w-full lg:w-3/4 xl:w-4/5 flex flex-col gap-4">
            <header class="glass-effect rounded-2xl p-6 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                <div><h1 class="text-3xl font-bold text-white">AI Trader Asistanı v2.5 (Gelişmiş)</h1><p class="text-gray-400">Tahminsel ve Adapte Olan Analiz</p></div>
                <div id="stats-container" class="glass-effect rounded-lg p-4 w-full md:w-auto text-center">
                    <h3 class="text-lg font-semibold text-white mb-2">Başarı İstatistiği</h3>
                    <div class="flex justify-around gap-4 text-sm">
                        <div><p class="text-gray-400">Toplam Sinyal</p><p id="total-signals" class="text-2xl font-bold text-white">0</p></div>
                        <div><p class="text-gray-400">Başarılı</p><p id="successful-signals" class="text-2xl font-bold text-green-400">0</p></div>
                        <div><p class="text-gray-400">Stop</p><p id="stopped-signals" class="text-2xl font-bold text-red-400">0</p></div>
                        <div><p class="text-gray-400">Başarı %</p><p id="success-rate" class="text-2xl font-bold text-blue-400">N/A</p></div>
                    </div>
                </div>
            </header>
            <div id="signals-grid" class="flex-grow overflow-y-auto p-2 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-4">
                 <div id="placeholder-card" class="flex flex-col items-center justify-center text-center text-gray-500 h-full col-span-full">
                    <svg class="w-16 h-16 mb-4 animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h7.5M8.25 12h7.5m-7.5 5.25h7.5M3.75 6.75h.007v.008H3.75V6.75zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zM3.75 12h.007v.008H3.75V12zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm-.375 5.25h.007v.008H3.75v-.008zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg>
                    <p class="text-xl font-medium">Uygulama Başlatılıyor...</p>
                </div>
            </div>
        </main>
    </div>
    <div id="details-modal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center hidden z-50 p-4">
        <div class="glass-effect rounded-2xl p-6 w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4"><h3 id="modal-title" class="text-2xl font-bold text-white">Analiz Detayları</h3><button id="close-modal" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button></div>
            <div id="modal-content" class="overflow-y-auto text-gray-300 space-y-4 pr-2"></div>
        </div>
    </div>

    <!-- AI Terminali -->
    <div id="ai-terminal">
        <div class="terminal-header">
            <div class="dots">
                <div class="dot dot-red"></div>
                <div class="dot dot-yellow"></div>
                <div class="dot dot-green"></div>
            </div>
            <span class="title">AI Trader Terminal v2.5</span>
            <div class="status">
                <div class="status-indicator"></div>
                <span>LIVE</span>
            </div>
        </div>
        <div class="terminal-body" id="terminal-output"></div>
        <div class="terminal-progress-bar">
            <div class="terminal-progress" id="terminal-progress-indicator">0%</div>
        </div>
    </div>

    <div id="critical-error-overlay" class="fixed inset-0 bg-red-900 bg-opacity-95 flex-col text-white items-center justify-center hidden z-[100] p-8 text-center">
        <h2 class="text-3xl font-bold mb-4">Kritik Hata: Kütüphane Başlatılamadı</h2>
        <p class="mb-2 max-w-2xl">Uygulamanın çalışması için gerekli olan 'technicalindicators' kütüphanesi başlatılamadı. Gömülü kodda bir sorun olabilir.</p>
    </div>
    
    <!-- Gömülü technicalindicators kütüphanesi (Gelişmiş ve Stabil Sürüm) -->
    <script>
        (function(global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
                typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (factory((global.technicalindicators = global.technicalindicators || {})));
        }(this, (function(exports) {
            'use strict';
            class Indicator {
                constructor() {
                    this.result = [];
                    this.format = (data) => {
                        return data;
                    };
                }
                static calculate(input) {
                    console.error('The calculate method is not implemented');
                    return;
                }
                getResult() {
                    return this.result;
                }
            }

            class MA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var result = new Array(values.length);
                    this.result = result;
                    this.generator = (function*() {
                        var sum = 0;
                        var period = yield;
                        var price = yield;
                        var data = new Array(period);
                        var i = 0;
                        var result;
                        while (true) {
                            if (i < period) {
                                data[i] = price;
                                sum = sum + price;
                                result = undefined;
                            } else {
                                sum = sum - data[i % period] + price;
                                result = sum / period;
                            }
                            i++;
                            data[i % period] = price;
                            price = yield result;
                        }
                    })();
                    this.generator.next();
                    this.generator.next(period);
                    values.forEach((tick, index) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result[index] = this.format(result.value);
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined)
                        return this.format(result);
                }
            }

            class SMA extends MA {
                constructor(input) {
                    super(input);
                }
                static calculate(input) {
                    var period = input.period;
                    var values = input.values;
                    var sma = new SMA({
                        period: period,
                        values: []
                    });
                    var results = [];
                    values.forEach(price => {
                        var result = sma.nextValue(price);
                        if(result !== undefined) results.push(result);
                    });
                    return results;
                }
            }

            class EMA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var k = 2 / (period + 1);
                    this.result = [];
                    this.generator = (function*() {
                        var last_ema;
                        var tick = yield;
                        var ma = new SMA({
                            period: period,
                            values: []
                        });
                        while (tick != undefined) {
                            var next_value = ma.nextValue(tick);
                            if (next_value != undefined) {
                                last_ema = next_value;
                                break;
                            }
                            tick = yield;
                        }
                        tick = yield last_ema;
                        while (true) {
                            last_ema = (tick - last_ema) * k + last_ema;
                            tick = yield last_ema;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                     return new EMA(input).getResult();
                }
            }
            
            class MACD extends Indicator {
                constructor(input) {
                    super();
                    var fastMAProducer = input.SimpleMAOscillator === false ? EMA : SMA;
                    var slowMAProducer = input.SimpleMAOscillator === false ? EMA : SMA;
                    var signalMAProducer = input.SimpleMASignal === false ? EMA : SMA;
                    var fastPeriod = input.fastPeriod;
                    var slowPeriod = input.slowPeriod;
                    var signalPeriod = input.signalPeriod;
                    var values = input.values;
                    var fastMA = new fastMAProducer({
                        period: fastPeriod,
                        values: []
                    });
                    var slowMA = new slowMAProducer({
                        period: slowPeriod,
                        values: []
                    });
                    var signalMA = new signalMAProducer({
                        period: signalPeriod,
                        values: []
                    });
                    this.result = [];
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var macd, signal, histogram;
                        while (true) {
                            var fast = fastMA.nextValue(tick);
                            var slow = slowMA.nextValue(tick);
                            if (fast != undefined && slow != undefined) {
                                macd = fast - slow;
                                signal = signalMA.nextValue(macd);
                                if (signal != undefined) {
                                    histogram = macd - signal;
                                }
                            }
                            result = {
                                MACD: macd,
                                signal: signal,
                                histogram: histogram
                            };
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value.MACD != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result.MACD != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new MACD(input).getResult();
                }
            }
            
            class RSI extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var values = input.values;
                    var GainProvider = new(function() {
                        var lastValue;
                        this.nextValue = function(value) {
                            if (lastValue === undefined) {
                                lastValue = value;
                                return;
                            }
                            var gainValue = value - lastValue;
                            lastValue = value;
                            return gainValue > 0 ? gainValue : 0;
                        };
                    })();
                    var LossProvider = new(function() {
                        var lastValue;
                        this.nextValue = function(value) {
                            if (lastValue === undefined) {
                                lastValue = value;
                                return;
                            }
                            var lossValue = value - lastValue;
                            lastValue = value;
                            return lossValue < 0 ? Math.abs(lossValue) : 0;
                        };
                    })();
                    var avgGain = new SMA({ period: period, values: [] });
                    var avgLoss = new SMA({ period: period, values: [] });
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var currentGain, currentLoss, lastAvgGain, lastAvgLoss, rs;
                        while (true) {
                            currentGain = GainProvider.nextValue(tick);
                            currentLoss = LossProvider.nextValue(tick);
                            if (currentGain === undefined || currentLoss === undefined) {
                                tick = yield;
                                continue;
                            }
                            if (lastAvgGain === undefined) {
                                lastAvgGain = avgGain.nextValue(currentGain);
                                lastAvgLoss = avgLoss.nextValue(currentLoss);
                                if (lastAvgGain !== undefined && lastAvgLoss !== undefined && lastAvgLoss !== 0) {
                                    rs = lastAvgGain / lastAvgLoss;
                                    result = 100 - 100 / (1 + rs);
                                }
                            } else {
                                lastAvgGain = (lastAvgGain * (period - 1) + currentGain) / period;
                                lastAvgLoss = (lastAvgLoss * (period - 1) + currentLoss) / period;
                                if(lastAvgLoss !== 0) {
                                    rs = lastAvgGain / lastAvgLoss;
                                    result = 100 - 100 / (1 + rs);
                                } else {
                                    result = 100;
                                }
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new RSI(input).getResult();
                }
            }

            class BollingerBands extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var values = input.values;
                    var stdDev = input.stdDev;
                    var ma = new SMA({ period: period, values: [] });
                    this.result = [];
                    this.generator = (function*() {
                        var result;
                        var tick = yield;
                        var data = new Array(period);
                        var i = 0;
                        while (true) {
                            data[i % period] = tick;
                            i++;
                            var middle = ma.nextValue(tick);
                            if (middle != undefined) {
                                var sum = 0;
                                for (var j = 0; j < data.length; j++) {
                                    sum = sum + (data[j] - middle) * (data[j] - middle);
                                }
                                var stdev = Math.sqrt(sum / period);
                                result = {
                                    middle: middle,
                                    upper: middle + stdev * stdDev,
                                    lower: middle - stdev * stdDev,
                                    pb: (tick - (middle - stdev * stdDev)) / ((middle + stdev * stdDev) - (middle - stdev * stdDev))
                                };
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new BollingerBands(input).getResult();
                }
            }

            class TrueRange extends Indicator {
                constructor(input) {
                    super();
                    this.high = input.high || [];
                    this.low = input.low || [];
                    this.close = input.close || [];
                    this.result = [];
                    this.generator = (function* () {
                        let lastClose;
                        let tick = yield;
                        while (true) {
                            let trueRange;
                            if (lastClose !== undefined) {
                                trueRange = Math.max(tick.high - tick.low, Math.abs(tick.high - lastClose), Math.abs(tick.low - lastClose));
                            } else {
                                trueRange = tick.high - tick.low;
                            }
                            lastClose = tick.close;
                            tick = yield trueRange;
                        }
                    })();
                    this.generator.next();
                    this.high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: this.low[index], close: this.close[index] };
                        const result = this.generator.next(tick);
                        if (result.value !== undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(tick) {
                    const result = this.generator.next(tick).value;
                    if (result !== undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new TrueRange(input).getResult();
                }
            }
            
            class WEMA extends Indicator {
                constructor(input) {
                    super(input);
                    var period = input.period;
                    var values = input.values;
                    var k = 1 / period;
                    this.result = [];
                    this.generator = (function*() {
                        var last_wema;
                        var tick = yield;
                        var ma = new SMA({ period: period, values: [] });
                        while (tick != undefined) {
                            var next_value = ma.nextValue(tick);
                            if (next_value != undefined) {
                                last_wema = next_value;
                                break;
                            }
                            tick = yield;
                        }
                        tick = yield last_wema;
                        while (true) {
                            last_wema = (tick * k) + (last_wema * (1 - k));
                            tick = yield last_wema;
                        }
                    })();
                    this.generator.next();
                    values.forEach((tick) => {
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new WEMA(input).getResult();
                }
            }

            class ATR extends Indicator {
                constructor(input) {
                    super();
                    let period = input.period;
                    let high = input.high || [];
                    let low = input.low || [];
                    let close = input.close || [];
                    let tr = new TrueRange({ high: [], low: [], close: [] });
                    let wildersSmoothing = new WEMA({ period: period, values: [] });
                    this.generator = (function* () {
                        let tick = yield;
                        let atr;
                        while (true) {
                            let trueRange = tr.nextValue(tick);
                            if (trueRange !== undefined) {
                                atr = wildersSmoothing.nextValue(trueRange);
                            }
                            tick = yield atr;
                        }
                    })();
                    this.generator.next();
                    high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: low[index], close: close[index] };
                        const result = this.generator.next(tick);
                        if (result.value !== undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(tick) {
                    const result = this.generator.next(tick).value;
                    if (result !== undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    const trueRanges = TrueRange.calculate(input);
                    const wema = new WEMA({ period: input.period, values: trueRanges });
                    return wema.getResult();
                }
            }

            class ADX extends Indicator {
                constructor(input) {
                    super();
                    var period = input.period;
                    var high = input.high;
                    var low = input.low;
                    var close = input.close;
                    var atr = new(function() {
                        var lastValue;
                        var trueRange;
                        var atr;
                        var atrSma = new SMA({ period: period, values: [] });
                        this.nextValue = function(tick) {
                            if (lastValue === undefined) {
                                lastValue = tick;
                                return;
                            }
                            trueRange = Math.max(tick.high - tick.low, Math.abs(tick.high - lastValue.close), Math.abs(tick.low - lastValue.close));
                            lastValue = tick;
                            if (atr === undefined) {
                                atr = atrSma.nextValue(trueRange);
                            } else {
                                atr = (atr * (period - 1) + trueRange) / period;
                            }
                            return atr;
                        };
                    })();
                    var adx;
                    var pdi;
                    var mdi;
                    var pdiSma = new SMA({ period: period, values: [] });
                    var mdiSma = new SMA({ period: period, values: [] });
                    var adxSma = new SMA({ period: period, values: [] });
                    var lastTick;
                    this.generator = (function*() {
                        var tick = yield;
                        var result;
                        while (true) {
                            if (lastTick === undefined) {
                                lastTick = tick;
                                tick = yield;
                                continue;
                            }
                            var upMove = tick.high - lastTick.high;
                            var downMove = lastTick.low - tick.low;
                            var pdiValue = (upMove > downMove && upMove > 0) ? upMove : 0;
                            var mdiValue = (downMove > upMove && downMove > 0) ? downMove : 0;
                            lastTick = tick;
                            var atrValue = atr.nextValue(tick);
                            if (atrValue === undefined || atrValue === 0) {
                                tick = yield;
                                continue;
                            }
                            if (pdi === undefined) {
                                pdi = pdiSma.nextValue(100 * pdiValue / atrValue);
                                mdi = mdiSma.nextValue(100 * mdiValue / atrValue);
                                if (pdi === undefined) {
                                    tick = yield;
                                    continue;
                                }
                            } else {
                                pdi = (pdi * (period - 1) + 100 * pdiValue / atrValue) / period;
                                mdi = (mdi * (period - 1) + 100 * mdiValue / atrValue) / period;
                            }
                            var dx = (pdi + mdi === 0) ? 0 : 100 * Math.abs(pdi - mdi) / (pdi + mdi);
                            if (adx === undefined) {
                                adx = adxSma.nextValue(dx);
                            } else {
                                adx = (adx * (period - 1) + dx) / period;
                            }
                            if (adx != undefined) {
                                result = {
                                    adx: adx,
                                    pdi: pdi,
                                    mdi: mdi
                                };
                            }
                            tick = yield result;
                        }
                    })();
                    this.generator.next();
                    high.forEach((tickHigh, index) => {
                        const tick = { high: tickHigh, low: low[index], close: close[index] };
                        var result = this.generator.next(tick);
                        if (result.value != undefined) {
                            this.result.push(this.format(result.value));
                        }
                    });
                }
                nextValue(price) {
                    var result = this.generator.next(price).value;
                    if (result != undefined) {
                        return this.format(result);
                    }
                }
                static calculate(input) {
                    return new ADX(input).getResult();
                }
            }

            exports.SMA = SMA;
            exports.EMA = EMA;
            exports.MACD = MACD;
            exports.RSI = RSI;
            exports.BollingerBands = BollingerBands;
            exports.ADX = ADX;
            exports.ATR = ATR;
            exports.TrueRange = TrueRange;
            exports.WEMA = WEMA;
            exports.Indicator = Indicator;

            Object.defineProperty(exports, '__esModule', { value: true });

        })));
    </script>
    
    <script type="module">
        // DOMContentLoaded olayı, tüm HTML'nin yüklenip ayrıştırılmasını bekler
        window.addEventListener('DOMContentLoaded', () => {
            // Kütüphaneyi güvenli bir şekilde global scope'a atama
            const ti = window.technicalindicators;

            // Güvenlik kontrolü: Kütüphane ve temel bir fonksiyon (RSI) var mı?
            if (!ti || !ti.RSI) {
                console.error("KRİTİK HATA: `technicalindicators` kütüphanesi veya RSI fonksiyonu bulunamadı. Gömülü kodda bir sorun olabilir.");
                const errorOverlay = document.getElementById('critical-error-overlay');
                if (errorOverlay) {
                    errorOverlay.classList.remove('hidden');
                    errorOverlay.classList.add('flex');
                }
                return; // Hata durumunda uygulamayı başlatma
            }

            // --- UYGULAMA KODU ---
            const config = {
                coinList: ['AIUSDT', 'ALGOUSDT', 'ALICEUSDT', 'ALPINEUSDT', 'ALTUSDT', 'AMPUSDT', 'ANKRUSDT', 'APEUSDT', 'API3USDT', 'APTUSDT', 'ARBUSDT', 'ARKMUSDT', 'ARKUSDT', 'ARPAUSDT', 'ARUSDT', 'ASRUSDT', 'ATMUSDT', 'ATOMUSDT', 'AUCTIONUSDT', 'AUDIOUSDT', 'AVAXUSDT', 'AXLUSDT', 'AXSUSDT', 'BAKEUSDT', 'BARUSDT', 'BBUSDT', 'BCHUSDT', 'BEAMXUSDT', 'BELUSDT', 'BLURUSDT', 'BNBUSDT', 'BOMEUSDT', 'BONKUSDT', 'BTTCUSDT', 'CAKEUSDT', 'CELOUSDT', 'CFXUSDT', 'CHZUSDT', 'CITYUSDT', 'CKBUSDT', 'COMPUSDT', 'COTIUSDT', 'CRVUSDT', 'CYBERUSDT', 'DENTUSDT', 'DOGEUSDT', 'DOTUSDT', 'DYDXUSDT', 'DYMUSDT', 'EDUUSDT', 'EGLDUSDT', 'ENAUSDT', 'ENJUSDT', 'ENSUSDT', 'ETCUSDT', 'ETHFIUSDT', 'ETHUSDT', 'FETUSDT', 'FILUSDT', 'FLOKIUSDT', 'GALAUSDT', 'GRTUSDT', 'HBARUSDT', 'HIGHUSDT', 'HOTUSDT', 'ICPUSDT', 'IDUSDT', 'INJUSDT', 'IOUSDT', 'IOTAUSDT', 'JASMYUSDT', 'JTOUSDT', 'JUPUSDT', 'JUVUSDT', 'LDOUSDT', 'LINKUSDT', 'LISTAUSDT', 'LPTUSDT', 'LRCUSDT', 'LTCUSDT', 'LUNCUSDT', 'MAGICUSDT', 'MANAUSDT', 'MANTAUSDT', 'MASKUSDT', 'MAVUSDT', 'MEMEUSDT', 'METISUSDT', 'MINAUSDT', 'MKRUSDT', 'NEARUSDT', 'NEOUSDT', 'NFPUSDT', 'NOTUSDT', 'NTRNUSDT', 'OGNUSDT', 'OGUSDT', 'OMNIUSDT', 'OMUSDT', 'ONDOUSDT', 'OPUSDT', 'ORDIUSDT', 'PENDLEUSDT', 'PEOPLEUSDT', 'PEPEUSDT', 'PIXELUSDT', 'POLYXUSDT', 'PORTALUSDT', 'PORTOUSDT', 'PSGUSDT', 'PYTHUSDT', 'QTUMUSDT', 'RNDRUSDT', 'RONINUSDT', 'ROSEUSDT', 'RSRUSDT', 'SAGAUSDT', 'SANDUSDT', 'SANTOSUSDT', 'SEIUSDT', 'SHIBUSDT', 'SKLUSDT', 'SNXUSDT', 'SOLUSDT', 'STORJUSDT', 'STRKUSDT', 'STXUSDT', 'SUIUSDT', 'SUPERUSDT', 'SUSHIUSDT', 'TAOUSDT', 'THETAUSDT', 'TIAUSDT', 'TLMUSDT', 'TNSRUSDT', 'TONUSDT', 'TRBUSDT', 'TRUUSDT', 'TRXUSDT', 'TWTUSDT', 'UMAUSDT', 'UNIUSDT', 'USDCUSDT', 'USTCUSDT', 'VETUSDT', 'WIFUSDT', 'WLDUSDT', 'WUSDT', 'XAIUSDT', 'XLMUSDT', 'XRPUSDT', 'XVGUSDT', 'ZILUSDT', 'ZKUSDT', 'ZROUSDT'],
                scanInterval: 15000, 
                cacheDuration: 1000 * 60 * 15, // 15 dakika
            };
            const UIElements = {
                coinList: document.getElementById('coin-list'),
                signalsGrid: document.getElementById('signals-grid'),
                stats: { total: document.getElementById('total-signals'), successful: document.getElementById('successful-signals'), stopped: document.getElementById('stopped-signals'), rate: document.getElementById('success-rate'), },
                modal: { container: document.getElementById('details-modal'), title: document.getElementById('modal-title'), content: document.getElementById('modal-content'), closeButton: document.getElementById('close-modal'), },
                connectionStatus: document.getElementById('connection-status'),
                coinSearch: document.getElementById('coin-search'),
                placeholderCard: document.getElementById('placeholder-card'),
                terminal: {
                    output: document.getElementById('terminal-output'),
                    progress: document.getElementById('terminal-progress-indicator'),
                }
            };
            let state = { coinsData: {}, activeSignals: {}, signalStats: { total: 0, successful: 0, stopped: 0 }, currentScanIndex: 0, klinesCache: new Map(), webSocket: null, indicatorSettings: {}, priorityList: [] };
            
            const terminalManager = {
                log(message, type = 'info') {
                    const now = new Date();
                    const timeString = now.toTimeString().split(' ')[0];
                    const p = document.createElement('p');
                    let icon = '';
                    let colorClass = '';
                    switch(type) {
                        case 'scan': icon = '🔍'; colorClass = 'log-scan'; break;
                        case 'success': icon = '✅'; colorClass = 'log-success'; break;
                        case 'error': icon = '❌'; colorClass = 'log-error'; break;
                        default: icon = 'ℹ️'; colorClass = 'log-info';
                    }
                    p.innerHTML = `<span class="icon">${icon}</span> <span>[${timeString}] ${message}</span>`;
                    p.className = colorClass;
                    UIElements.terminal.output.appendChild(p);
                    UIElements.terminal.output.scrollTop = UIElements.terminal.output.scrollHeight;
                },
                updateProgress(currentIndex, total) {
                    const percentage = total > 0 ? ((currentIndex / total) * 100) : 0;
                    UIElements.terminal.progress.style.width = `${percentage.toFixed(2)}%`;
                    UIElements.terminal.progress.textContent = `${percentage.toFixed(0)}%`;
                }
            };

            const apiManager = {
                baseUrl: 'https://api.binance.com/api/v3',
                async get24hTickers() { try { const response = await fetch(`${this.baseUrl}/ticker/24hr`); if (!response.ok) throw new Error(`API Error: ${response.status}`); return await response.json(); } catch (error) { console.error("Ticker verileri alınamadı:", error); terminalManager.log('Piyasa verileri alınamadı.', 'error'); return []; } },
                async getKlines(symbol, interval, limit = 200) { const cacheKey = `${symbol}_${interval}`; const cached = state.klinesCache.get(cacheKey); if (cached && (Date.now() - cached.timestamp < config.cacheDuration)) { return cached.data; } try { const response = await fetch(`${this.baseUrl}/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`); if (!response.ok) throw new Error(`API Error: ${response.status}`); const data = await response.json(); state.klinesCache.set(cacheKey, { data, timestamp: Date.now() }); return data; } catch (error) { console.error(`${symbol} için ${interval} klines verisi alınamadı:`, error); terminalManager.log(`${symbol} için veri alınamadı.`, 'error'); return null; } }
            };

            const indicatorCalculator = {
                initializeSettings(symbol) { 
                    if (!state.indicatorSettings[symbol]) { 
                        state.indicatorSettings[symbol] = { 
                            rsiPeriod: 14, 
                            macd: { fastPeriod: 12, slowPeriod: 26, signalPeriod: 9 }, 
                            bbPeriod: 20, 
                            adxPeriod: 14,
                            atrPeriod: 14
                        }; 
                    } 
                },
                calculateAll(symbol, klines) { 
                    if (!klines || klines.length < 30) return null; 
                    this.initializeSettings(symbol); 
                    const settings = state.indicatorSettings[symbol]; 
                    
                    const inputs = {
                        open: klines.map(k => parseFloat(k[1])),
                        high: klines.map(k => parseFloat(k[2])),
                        low: klines.map(k => parseFloat(k[3])),
                        close: klines.map(k => parseFloat(k[4])),
                        volume: klines.map(k => parseFloat(k[5])),
                    };

                    const calculateVWAP = (klines) => {
                        let cumulativePV = 0;
                        let cumulativeVolume = 0;
                        klines.forEach(k => {
                            const high = parseFloat(k[2]);
                            const low = parseFloat(k[3]);
                            const close = parseFloat(k[4]);
                            const volume = parseFloat(k[5]);
                            const typicalPrice = (high + low + close) / 3;
                            cumulativePV += typicalPrice * volume;
                            cumulativeVolume += volume;
                        });
                        return cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : 0;
                    };

                    const getMarketStructure = (klines) => {
                        const recentKlines = klines.slice(-10); // Son 10 muma bak
                        const highs = recentKlines.map(k => parseFloat(k[2]));
                        const lows = recentKlines.map(k => parseFloat(k[3]));
                        
                        if(highs.length < 3) return "Belirsiz";

                        const lastHigh = highs[highs.length - 1];
                        const prevHigh = Math.max(...highs.slice(0, highs.length - 2));
                        const lastLow = lows[lows.length - 1];
                        const prevLow = Math.min(...lows.slice(0, lows.length - 2));

                        if (lastHigh > prevHigh && lastLow > prevLow) return "Yükseliş Trendi (HH/HL)";
                        if (lastHigh < prevHigh && lastLow < prevLow) return "Düşüş Trendi (LH/LL)";
                        return "Yatay Piyasa";
                    };

                    try { 
                        const vwap = calculateVWAP(klines);
                        const vwapDeviation = vwap > 0 ? ((inputs.close[inputs.close.length - 1] - vwap) / vwap * 100).toFixed(2) : 0;
                        const marketStructure = getMarketStructure(klines);
                        
                        return { 
                            rsi: ti.RSI.calculate({ values: inputs.close, period: settings.rsiPeriod }).pop()?.toFixed(2), 
                            macd: ti.MACD.calculate({ ...settings.macd, values: inputs.close, SimpleMAOscillator: false, SimpleMASignal: false }).pop(), 
                            bb: ti.BollingerBands.calculate({ period: settings.bbPeriod, values: inputs.close, stdDev: 2 }).pop(), 
                            adx: ti.ADX.calculate({ period: settings.adxPeriod, high: inputs.high, low: inputs.low, close: inputs.close }).pop(),
                            atr: ti.ATR.calculate({ period: settings.atrPeriod, high: inputs.high, low: inputs.low, close: inputs.close }).pop()?.toFixed(4),
                            vwapDeviation: vwapDeviation,
                            marketStructure: marketStructure
                        }; 
                    } catch (error) { 
                        console.error(`${symbol} için indikatör hesaplama hatası:`, error); 
                        terminalManager.log(`${symbol} indikatör hatası.`, 'error');
                        return null; 
                    } 
                },
            };

            const aiCore = {
                createPrompt(symbol, price, data) { 
                    const formatIndicators = (indicators) => { 
                        if (!indicators) return "Hesaplanamadı."; 
                        const macdHistogram = indicators.macd && indicators.macd.histogram ? indicators.macd.histogram.toFixed(4) : "N/A";
                        const adxValue = indicators.adx && indicators.adx.adx ? indicators.adx.adx.toFixed(2) : "N/A";
                        return `RSI: ${indicators.rsi}, MACD Hist: ${macdHistogram}, ADX: ${adxValue}`; 
                    }; 
                    const btcContext = `4s BTC Trendi: ${data.btc.trend}, 4s BTC RSI: ${data.btc.rsi}`; 
                    return `Sen, dünya standartlarında, elit bir kantitatif trader asistanısın. Görevin, sana sağlanan çok çeşitli teknik ve yapısal verileri analiz ederek, yüksek olasılıklı, gerçekçi ve kısa vadeli 'AL' sinyalleri üretmektir. Sadece veriye dayalı, matematiksel ve profesyonel kararlar ver.
                        PİYASA GENEL DURUMU (BTC): ${btcContext}
                        ANALİZ EDİLECEK COIN: ${symbol}
                        MEVCUT FİYAT: ${price}
                        İŞLENMİŞ TEKNİK VERİLER:
                        - 15 Dakikalık İndikatörler: ${formatIndicators(data.indicators.m15)}
                        - 1 Saatlik İndikatörler: ${formatIndicators(data.indicators.h1)}
                        - 4 Saatlik İndikatörler: ${formatIndicators(data.indicators.h4)}
                        - 1 Günlük İndikatörler: ${formatIndicators(data.indicators.d1)}
                        YAPISAL VERİLER:
                        - 4s Piyasa Yapısı (Son 10 mum): ${data.indicators.h4?.marketStructure}
                        - 4s VWAP Sapması (%): ${data.indicators.h4?.vwapDeviation}
                        - Günlük Volatilite (ATR): ${data.indicators.d1?.atr}
                        GÖREV: Yukarıdaki teknik ve yapısal verileri bütünsel olarak analiz et. ${symbol} için bir 'AL' sinyali oluşturmanın mantıklı olup olmadığını değerlendir. Cevabını MUTLAKA aşağıdaki JSON formatında ver. Açıklama ekleme, sadece JSON çıktısı ver.
                        {
                          "shouldSignal": boolean,
                          "confidenceScore": number,
                          "analysisRationale": "Karar sürecini, sana verdiğim tüm indikatörlere (RSI, MACD, ADX), piyasa yapısına, VWAP sapmasına ve BTC durumuna atıfta bulunarak detaylıca açıkla. Farklı zaman dilimlerindeki uyum veya uyumsuzlukları belirt. Örneğin: '4 saatlik grafikte Yükseliş Trendi (HH/HL) yapısı teyit edildi. Fiyat, VWAP'ın %2 altında, bu da potansiyel bir alım fırsatına işaret ediyor. MACD pozitif bölgeye geçmiş ve günlük ADX trendin güçlendiğini gösteriyor. Bitcoin'in de yükseliş trendinde olması bu sinyali güçlendiriyor. Stop-loss seviyesi, günlük ATR değeri ve bir önceki dip seviyesi dikkate alınarak belirlenmiştir.'",
                          "targets": { "tp1": number, "tp2": number },
                          "stopLoss": number
                        }
                        HEDEF BELİRLEME KURALLARI (ÇOK ÖNEMLİ):
                        1. Gerçekçi ve Ulaşılabilir Ol: Hedefler hayali olmamalı. Kısa vadeli (saatlik/günlük) hedefler belirle.
                        2. TP1 (Hedef 1): En yakın ve bariz likidite (direnç) bölgesi olmalı. Fiyatın zorlanmadan ulaşabileceği ilk mantıklı seviye.
                        3. TP2 (Hedef 2): Daha güçlü, bir üstteki direnç bölgesi olmalı. TP1'in kırılması durumunda potansiyel hedef.
                        4. Stop Loss (SL): Fiyat yapısını bozacak en yakın ve en mantıklı destek seviyesinin hemen altı olmalı. İşlemin geçersiz olacağı seviyeyi doğru belirle.
                        5. Risk/Kazanç Oranı: Belirlediğin hedeflerin, SL'e göre makul bir risk/kazanç oranı sunduğundan emin ol.
                        GENEL KURALLAR:
                        - 'shouldSignal' sadece tüm veriler güçlü bir yükseliş potansiyeli gösterdiğinde ve BTC durumu riskli değilse 'true' olmalı.
                        - 'confidenceScore' (1-10 arası) sinyale olan güvenini belirtmeli. 7'den düşükse sinyal üretme.
                        - 'analysisRationale' şeffaf, veriye dayalı ve profesyonel olmalı.
                        `; 
                },
                async analyzeCoin(symbol, price, data) {
                    const userPrompt = this.createPrompt(symbol, price, data);
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: userPrompt }] }],
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    "shouldSignal": { "type": "BOOLEAN" },
                                    "confidenceScore": { "type": "NUMBER" },
                                    "analysisRationale": { "type": "STRING" },
                                    "targets": {
                                        "type": "OBJECT",
                                        properties: {
                                            "tp1": { "type": "NUMBER" },
                                            "tp2": { "type": "NUMBER" }
                                        },
                                        required: ["tp1", "tp2"]
                                    },
                                    "stopLoss": { "type": "NUMBER" }
                                },
                                required: ["shouldSignal", "confidenceScore", "analysisRationale", "targets", "stopLoss"]
                            }
                        }
                    };
                    const apiKey = ""; // Canvas ortamı için boş bırakın
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error("Gemini API Hata Yanıtı:", errorText);
                            throw new Error(`Gemini API Hatası: ${response.status} ${response.statusText}`);
                        }

                        const result = await response.json();
                        
                        if (result.candidates && result.candidates[0]?.content?.parts[0]) {
                            const text = result.candidates[0].content.parts[0].text;
                            try {
                                return JSON.parse(text);
                            } catch (e) {
                                console.error("Gemini yanıtından JSON ayrıştırılamadı:", text, e);
                                terminalManager.log(`${symbol} AI yanıtı anlaşılamadı.`, 'error');
                                return null;
                            }
                        } else {
                            console.error("Beklenmedik Gemini API yanıt yapısı:", result);
                            terminalManager.log(`${symbol} AI'dan beklenmedik yanıt.`, 'error');
                            return null;
                        }
                    } catch (error) {
                        console.error("Gemini analizi başarısız:", error);
                        terminalManager.log(`${symbol} AI analizi başarısız.`, 'error');
                        uiManager.setScanStatus(symbol, "Analiz Hatası!");
                        return null;
                    }
                }
            };

            const uiManager = {
                updateCoinList() { const sortedCoins = Object.values(state.coinsData).filter(c => config.coinList.includes(c.s)).sort((a, b) => parseFloat(b.P) - parseFloat(a.P)); UIElements.coinList.innerHTML = ''; const searchTerm = UIElements.coinSearch.value.toLowerCase(); sortedCoins.filter(coin => coin.s.toLowerCase().includes(searchTerm)).forEach(coin => { const price = parseFloat(coin.c).toFixed(Math.max(2, (coin.c.split('.')[1] || '').length)); const change = parseFloat(coin.P); const changeColor = change >= 0 ? 'text-green-400' : 'text-red-400'; const coinEl = document.createElement('div'); coinEl.id = `coin-${coin.s}`; coinEl.className = 'flex justify-between items-center p-2 rounded-lg hover:bg-gray-800/50 transition-colors cursor-pointer'; coinEl.innerHTML = `<div class="flex items-center gap-3"><img src="https://s2.coinmarketcap.com/static/img/coins/64x64/${coin.s.replace('USDT', '').toLowerCase()}.png" onerror="this.onerror=null;this.src='https://placehold.co/32x32/161b22/c9d1d9?text=${coin.s[0]}';" alt="${coin.s}" class="w-8 h-8 rounded-full"><div><p class="font-bold text-sm text-white">${coin.s.replace('USDT', '')}</p><p class="text-xs text-gray-400" id="price-${coin.s}">$${price}</p></div></div><div class="text-right"><p class="font-semibold text-sm ${changeColor}">${change.toFixed(2)}%</p><p class="text-xs text-gray-500" id="status-${coin.s}"></p></div>`; UIElements.coinList.appendChild(coinEl); }); },
                updateLivePrice(data) { 
                    const newPrice = parseFloat(data.c);
                    const formattedPrice = newPrice.toFixed(Math.max(2, (data.c.split('.')[1] || '').length));

                    // Sol taraftaki liste fiyatını güncelle
                    const priceEl = document.getElementById(`price-${data.s}`); 
                    if (priceEl) { 
                        const oldPrice = parseFloat(priceEl.innerText.replace('$', '')); 
                        const priceColor = newPrice > oldPrice ? 'text-green-400' : newPrice < oldPrice ? 'text-red-400' : 'text-gray-400'; 
                        priceEl.innerText = `$${formattedPrice}`; 
                        priceEl.classList.remove('text-green-400', 'text-red-400', 'text-gray-400'); 
                        priceEl.classList.add(priceColor); 
                        setTimeout(() => priceEl.classList.remove(priceColor), 500); 
                    }

                    // Aktif sinyal kartı varsa onu da güncelle
                    if(state.activeSignals[data.s]) {
                        this.updateSignalProgressBar(data.s, newPrice);
                        
                        const signalPriceEl = document.getElementById(`live-price-signal-${data.s}`);
                        if (signalPriceEl) {
                            const oldPrice = parseFloat(signalPriceEl.textContent);
                            const priceColor = newPrice > oldPrice ? 'text-green-400' : newPrice < oldPrice ? 'text-red-400' : 'text-gray-300';
                            signalPriceEl.textContent = formattedPrice;
                            signalPriceEl.classList.remove('text-green-400', 'text-red-400', 'text-gray-300');
                            signalPriceEl.classList.add(priceColor);
                        }
                    }
                },
                setScanStatus(symbol, text) { const statusEl = document.getElementById(`status-${symbol}`); if (statusEl) { statusEl.innerHTML = `<span class="blinking">${text}</span>`; } },
                createSignalCard(symbol, signalData, entryPrice) { 
                    if (UIElements.placeholderCard) { UIElements.placeholderCard.remove(); UIElements.placeholderCard = null; } 
                    
                    const tp1_profit_pct = ((signalData.targets.tp1 - entryPrice) / entryPrice * 100).toFixed(2);
                    const tp2_profit_pct = ((signalData.targets.tp2 - entryPrice) / entryPrice * 100).toFixed(2);
                    const sl_loss_pct = ((signalData.stopLoss - entryPrice) / entryPrice * 100).toFixed(2);

                    const signalId = `signal-${symbol}-${Date.now()}`; 
                    const card = document.createElement('div'); 
                    card.id = signalId; 
                    card.className = 'signal-card glass-effect rounded-lg p-4 flex flex-col space-y-3 border-l-emerald-500'; 
                    card.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2">
                                <img src="https://s2.coinmarketcap.com/static/img/coins/64x64/${symbol.replace('USDT', '').toLowerCase()}.png" onerror="this.onerror=null;this.src='https://placehold.co/24x24/161b22/c9d1d9?text=${symbol[0]}';" alt="${symbol}" class="w-6 h-6 rounded-full">
                                <h4 class="text-lg font-bold text-white">${symbol.replace('USDT','')}</h4>
                                <span id="live-price-signal-${symbol}" class="font-mono text-lg text-gray-300 ml-2">${parseFloat(entryPrice).toFixed(Math.max(2, (entryPrice.split('.')[1] || '').length))}</span>
                            </div>
                            <div class="px-2 py-1 rounded text-xs font-bold bg-emerald-500/20 text-emerald-300">Güven: ${signalData.confidenceScore}/10</div>
                        </div>
                        <div id="status-box-${signalId}" class="text-center p-2 rounded-lg bg-gray-800/60">
                            <p class="text-sm font-medium text-yellow-300">AKTİF</p>
                            <p class="text-xs text-gray-400">Hedefler bekleniyor</p>
                        </div>
                        <div class="grid grid-cols-3 gap-x-4 gap-y-2 text-sm">
                            <div class="text-gray-400">Giriş Fiyatı</div>
                            <div class="text-right font-mono text-white col-span-2">${entryPrice}</div>

                            <div class="text-gray-400">Hedef 1 (TP1)</div>
                            <div class="text-right font-mono text-green-400">${signalData.targets.tp1}</div>
                            <div class="text-right font-mono text-green-500">(+${tp1_profit_pct}%)</div>

                            <div class="text-gray-400">Hedef 2 (TP2)</div>
                            <div class="text-right font-mono text-green-300">${signalData.targets.tp2}</div>
                            <div class="text-right font-mono text-green-400">(+${tp2_profit_pct}%)</div>

                            <div class="text-gray-400">Stop Loss (SL)</div>
                            <div class="text-right font-mono text-red-400">${signalData.stopLoss}</div>
                            <div class="text-right font-mono text-red-500">(${sl_loss_pct}%)</div>
                        </div>
                        <div class="mt-2">
                            <div class="price-progress-bar" id="progress-bar-${signalId}">
                                <div class="price-indicator" id="price-indicator-${signalId}"></div>
                            </div>
                        </div>
                        <button data-symbol="${symbol}" data-rationale="${encodeURIComponent(signalData.analysisRationale)}" class="details-btn mt-2 w-full bg-blue-600/50 hover:bg-blue-600/80 text-white text-sm font-semibold py-2 rounded-lg transition-colors">Analiz Detayları</button>`; 
                    UIElements.signalsGrid.prepend(card); 
                    this.updateStats(true); 
                    state.activeSignals[symbol] = { ...signalData, id: signalId, status: 'active', entryPrice: parseFloat(entryPrice) }; 
                    this.updateSignalProgressBar(symbol, parseFloat(entryPrice));
                },
                updateSignalProgressBar(symbol, currentPrice) {
                    const signal = state.activeSignals[symbol];
                    if (!signal) return;

                    const progressBar = document.getElementById(`progress-bar-${signal.id}`);
                    const priceIndicator = document.getElementById(`price-indicator-${signal.id}`);

                    if (!progressBar || !priceIndicator) return;

                    const { stopLoss, targets } = signal;
                    const tp2 = targets.tp2;

                    const totalRange = tp2 - stopLoss;
                    if (totalRange <= 0) return;

                    const currentProgress = currentPrice - stopLoss;
                    let progressPct = (currentProgress / totalRange) * 100;
                    
                    // Çubuğun %0 ile %100 arasında kalmasını sağla
                    progressPct = Math.max(0, Math.min(100, progressPct));

                    priceIndicator.style.left = `${progressPct}%`;
                },
                updateSignalStatus(symbol, status) { const signal = state.activeSignals[symbol]; if (!signal || signal.status !== 'active') return; signal.status = status; const statusBox = document.getElementById(`status-box-${signal.id}`); if (statusBox) { if (status === 'successful') { statusBox.innerHTML = `<p class="text-sm font-medium text-green-400">BAŞARILI</p><p class="text-xs text-gray-400">Hedefe ulaşıldı!</p>`; statusBox.parentElement.classList.remove('border-l-emerald-500'); statusBox.parentElement.classList.add('border-l-green-400'); this.updateStats(false, true, false); } else if (status === 'stopped') { statusBox.innerHTML = `<p class="text-sm font-medium text-red-400">STOP OLDU</p><p class="text-xs text-gray-400">Stop seviyesine ulaşıldı.</p>`; statusBox.parentElement.classList.remove('border-l-emerald-500'); statusBox.parentElement.classList.add('border-l-red-400'); this.updateStats(false, false, true); } } delete state.activeSignals[symbol]; },
                updateStats(isNew = false, isSuccess = false, isStop = false) {
                    if (isNew) state.signalStats.total++;
                    if (isSuccess) state.signalStats.successful++;
                    if (isStop) state.signalStats.stopped++;

                    UIElements.stats.total.textContent = state.signalStats.total;
                    UIElements.stats.successful.textContent = state.signalStats.successful;
                    UIElements.stats.stopped.textContent = state.signalStats.stopped;

                    const concludedSignals = state.signalStats.successful + state.signalStats.stopped;
                    if (concludedSignals > 0) {
                        const successRate = (state.signalStats.successful / concludedSignals) * 100;
                        UIElements.stats.rate.textContent = `${successRate.toFixed(1)}%`;
                    } else {
                        UIElements.stats.rate.textContent = 'N/A';
                    }
                },
                toggleModal(show, title = '', content = '') { if (show) { UIElements.modal.title.textContent = `${title.replace('USDT','')} Analiz Detayları`; UIElements.modal.content.innerHTML = `<p>${decodeURIComponent(content).replace(/\n/g, '<br>')}</p>`; UIElements.modal.container.classList.remove('hidden'); UIElements.modal.container.classList.add('flex'); } else { UIElements.modal.container.classList.add('hidden'); UIElements.modal.container.classList.remove('flex');} },
                setConnectionStatus(connected) { const dot = UIElements.connectionStatus.querySelector('.status-dot'); const text = UIElements.connectionStatus.querySelector('span'); if(connected){ dot.classList.remove('bg-yellow-400', 'bg-red-400'); dot.classList.add('bg-green-400'); text.textContent = 'Bağlandı'; } else { dot.classList.remove('bg-green-400'); dot.classList.add('bg-red-400'); text.textContent = 'Bağlantı Kesildi'; } }
            };

            const App = {
                async init() { 
                    terminalManager.log('Uygulama başlatılıyor...');
                    const tickers = await apiManager.get24hTickers(); 
                    terminalManager.log('Piyasa verileri alındı.');
                    tickers.forEach(t => { if (config.coinList.includes(t.symbol)) { state.coinsData[t.symbol] = { s: t.symbol, c: t.lastPrice, P: t.priceChangePercent, q: t.quoteVolume }; } }); 
                    uiManager.updateCoinList(); 
                    this.setupEventListeners(); 
                    this.startWebSocket(); 
                    setTimeout(() => this.scanLoop(), 2000); 
                },
                updatePriorityList() {
                    terminalManager.log('Piyasa analiz ediliyor ve öncelik listesi oluşturuluyor...');
                    const allCoins = Object.values(state.coinsData).filter(c => c && config.coinList.includes(c.s));

                    const scoredCoins = allCoins
                        .map(coin => {
                            const priceChange = parseFloat(coin.P);
                            const volume = parseFloat(coin.q);
                            if (priceChange <= 0 || volume <= 0 || !isFinite(volume)) {
                                return { s: coin.s, score: -Infinity };
                            }
                            const score = priceChange * Math.log10(volume);
                            return { s: coin.s, score };
                        })
                        .filter(coin => isFinite(coin.score))
                        .sort((a, b) => b.score - a.score);

                    state.priorityList = scoredCoins.slice(0, 50).map(c => c.s);
                    terminalManager.log(`Öncelikli ${state.priorityList.length} coin belirlendi. Tarama başlıyor.`, 'success');
                },
                setupEventListeners() { UIElements.coinSearch.addEventListener('input', () => uiManager.updateCoinList()); UIElements.modal.closeButton.addEventListener('click', () => uiManager.toggleModal(false)); UIElements.signalsGrid.addEventListener('click', (e) => { const button = e.target.closest('.details-btn'); if (button) { const { symbol, rationale } = button.dataset; uiManager.toggleModal(true, symbol, rationale); } }); },
                startWebSocket() { 
                    terminalManager.log('Canlı veri akışına bağlanılıyor...');
                    const streams = config.coinList.map(s => `${s.toLowerCase()}@ticker`).join('/'); 
                    if (state.webSocket) { state.webSocket.close(); }
                    state.webSocket = new WebSocket(`wss://stream.binance.com:9443/ws/${streams}`); 
                    state.webSocket.onopen = () => { uiManager.setConnectionStatus(true); terminalManager.log('Canlı veri akışı aktif!', 'success'); }; 
                    state.webSocket.onmessage = (event) => { 
                        const data = JSON.parse(event.data); 
                        if (data.e === '24hrTicker') { 
                            if(state.coinsData[data.s]) { 
                                state.coinsData[data.s].c = data.c; 
                                state.coinsData[data.s].P = data.P; 
                                state.coinsData[data.s].q = data.q; 
                            } 
                            uiManager.updateLivePrice(data); 
                            this.checkActiveSignals(data.s, parseFloat(data.c)); 
                        } 
                    }; 
                    state.webSocket.onclose = () => { uiManager.setConnectionStatus(false); terminalManager.log('Canlı veri bağlantısı kesildi. 5 saniye içinde yeniden denenecek...', 'error'); setTimeout(() => this.startWebSocket(), 5000); }; 
                    state.webSocket.onerror = (error) => { console.error("WebSocket Hatası:", error); uiManager.setConnectionStatus(false); state.webSocket.close(); }; 
                },
                checkActiveSignals(symbol, price) { const signal = state.activeSignals[symbol]; if (signal && signal.status === 'active') { if (price >= signal.targets.tp2) { terminalManager.log(`${symbol} tüm hedeflere ulaştı! (TP2)`, 'success'); uiManager.updateSignalStatus(symbol, 'successful'); } else if (price >= signal.targets.tp1) { const statusBox = document.getElementById(`status-box-${signal.id}`); if(statusBox && !statusBox.innerText.includes("TP1 BAŞARILI")) { terminalManager.log(`${symbol} hedef 1'e ulaştı! (TP1)`, 'success'); statusBox.innerHTML = `<p class="text-sm font-medium text-cyan-300">TP1 BAŞARILI</p><p class="text-xs text-gray-400">TP2 bekleniyor</p>`; } } else if (price <= signal.stopLoss) { terminalManager.log(`${symbol} stop oldu.`, 'error'); uiManager.updateSignalStatus(symbol, 'stopped'); } } },
                async scanLoop() {
                    if (state.currentScanIndex === 0 || state.currentScanIndex >= state.priorityList.length) {
                        if (state.currentScanIndex >= state.priorityList.length) {
                            terminalManager.log('Öncelik listesi taraması tamamlandı. Liste güncelleniyor.');
                        }
                        state.currentScanIndex = 0;
                        this.updatePriorityList();
                        
                        if (state.priorityList.length === 0) {
                            terminalManager.log('Analiz edilecek öncelikli coin bulunamadı. Tekrar denenecek.', 'error');
                            setTimeout(() => this.scanLoop(), config.scanInterval * 2);
                            return;
                        }
                    }
                    
                    terminalManager.updateProgress(state.currentScanIndex + 1, state.priorityList.length);

                    const symbol = state.priorityList[state.currentScanIndex];
                    const coinToScan = state.coinsData[symbol];

                    if (!coinToScan) {
                        console.error(`Öncelik listesindeki ${symbol} için veri bulunamadı.`);
                        state.currentScanIndex++;
                        setTimeout(() => this.scanLoop(), 1000);
                        return;
                    }

                    if (!state.activeSignals[symbol]) {
                        uiManager.setScanStatus(symbol, "Analiz ediliyor...");
                        terminalManager.log(`${symbol} analiz ediliyor...`, 'scan');
                        
                        const btcKlines = await apiManager.getKlines('BTCUSDT', '4h');
                        const btcIndicators = indicatorCalculator.calculateAll('BTCUSDT', btcKlines);
                        
                        if (btcIndicators) {
                            const klines = {
                                m15: await apiManager.getKlines(symbol, '15m'),
                                h1: await apiManager.getKlines(symbol, '1h'),
                                h4: await apiManager.getKlines(symbol, '4h'),
                                d1: await apiManager.getKlines(symbol, '1d'),
                            };
                            const indicators = {
                                m15: indicatorCalculator.calculateAll(symbol, klines.m15),
                                h1: indicatorCalculator.calculateAll(symbol, klines.h1),
                                h4: indicatorCalculator.calculateAll(symbol, klines.h4),
                                d1: indicatorCalculator.calculateAll(symbol, klines.d1),
                            };
                            if (Object.values(indicators).every(d => d !== null)) {
                                const analysisData = {
                                    indicators: indicators,
                                    btc: {
                                        rsi: btcIndicators.rsi,
                                        trend: btcIndicators.macd.histogram > 0 ? 'Yükseliş' : 'Düşüş'
                                    }
                                };
                                const analysisResult = await aiCore.analyzeCoin(symbol, coinToScan.c, analysisData);
                                if (analysisResult && analysisResult.shouldSignal && analysisResult.confidenceScore >= 7) {
                                    uiManager.createSignalCard(symbol, analysisResult, coinToScan.c);
                                    terminalManager.log(`${symbol} için yeni sinyal bulundu!`, 'success');
                                }
                            }
                        }
                    }
                    uiManager.setScanStatus(symbol, "");
                    state.currentScanIndex++;
                    setTimeout(() => this.scanLoop(), config.scanInterval);
                },
            };
            
            App.init();
        });
    </script>
</body>
</html>
